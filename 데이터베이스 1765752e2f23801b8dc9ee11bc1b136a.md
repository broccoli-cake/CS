# 데이터베이스

---

# 데이터베이스 개요

---

## 데이터베이스의 정의와 필요성

**데이터베이스**

- **정의**: 특정 조직의 여러 사용자가 공유하여 사용할 수 있도록 통합해서 ‘저장’한 ‘운영’ 데이터의 집합

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image.png)

**데이터베이스의 핵심 개념**

- **공유 데이터**: 사용 목적이 다른 사용자들을 두루 고려하여 데이터베이스를 구성해야 한다.
- **통합 데이터**: 중복을 최소화하고 통제가 가능한 중복만 허용하는 데이터이다.
- **저장 데이터**: 컴퓨터가 접근할 수 있는 매체에 데이터베이스를 저장해야 한다.
- **운영 데이터**: 일시적이 아니라 지속적으로 유지해야 하는 데이터이다.

---

## 파일 시스템과 데이터베이스의 차이

**파일 시스템**

- **정의:**
    - 오래 전부터 사용되어 온 정보 처리 시스템으로 데이터를 파일로 관리할 수 있도록 파일을 생성, 삭제 수정 검색하는 기능을 제공하며, 운영체제와 함께 설치된다.
- **장점:**
    - 별도의 구매 비용이 들지 않는다.
- **단점:**
    - **데이터 중복 문제**
        - 같은 데이터가 여러 파일에 중복 저장되어 저장 공간이 낭비되고, 데이터 일관성과 무결성을 유지하기 어렵다.
        - **예**: 고객 연락처를 수정했지만 주문 파일은 수정하지 않은 경우.
    - **데이터 종속성**
        - 파일 구조가 바뀌면 관련 응용 프로그램도 수정해야 한다.
        - **예**: 고객 파일에 '나이'가 추가되면, 이를 사용하는 모든 프로그램을 수정해야 한다.
    - **공유 및 보안 기능 부족**
        - 동시 접근이 어렵고, 세부적인 접근 권한 설정이 불가능하다.
    - **개발의 어려움**
        - 데이터 관리 작업을 모두 응용 프로그램이 처리해야 하므로 개발이 복잡하다.

**파일 시스템에서 데이터베이스로 변경 시 개선 사항**

1. **데이터 중복 최소화**
    - 데이터가 여러 파일에 중복 저장되는 문제를 해결하여 저장 공간을 효율적으로 사용한다.
2. **데이터와 프로그램의 독립성 확보**
    - 파일 구조가 변경되더라도 응용 프로그램 수정 없이 데이터에 접근 가능하다.
3. **동시 접근과 보안 강화**
    - 여러 사용자가 동시에 데이터를 사용할 수 있으며, 세부적인 접근 권한 설정이 가능하다.
4. **자동화된 데이터 관리**
    - 데이터 추가, 수정, 삭제 등 관리 작업을 DBMS가 자동으로 처리하여 개발과 운영이 더 쉬워진다.

| **구분** | **파일 시스템** | **데이터베이스** |
| --- | --- | --- |
| **데이터 중복** | 데이터 중복이 발생하기 쉬움 | 데이터 중복 최소화 |
| **데이터 무결성** | 별도의 프로그램으로 관리 필요 | 데이터베이스 관리 시스템(DBMS)이 무결성을 보장 |
| **데이터 보안** | 제한적인 보안 제공 | 세분화된 보안 관리 가능 |
| **데이터 접근성** | 특정 데이터 접근이 어려움 | SQL을 사용해 빠르고 간편한 데이터 접근 가능 |
| **데이터 일관성** | 데이터 중복으로 일관성 유지가 어려움 | 통합된 데이터베이스 구조로 일관성 유지 가능 |
| **확장성** | 대규모 데이터 처리에 비효율적 | 대규모 데이터와 사용자 처리에 유리 |

---

## 데이터베이스의 특징

1. **무결성 (Integrity)**
    - 데이터의 **정확성**과 **일관성**을 유지하며, 오류가 발생하지 않도록 관리한다.
    - 예: 학생의 학번은 중복될 수 없도록 보장.
2. **일관성 (Consistency)**
    - 데이터베이스 상태가 트랜잭션 전후로 **일관성을 유지한다.**
    - 예: 은행 계좌 이체 시 송금과 입금이 동시에 완료되거나 동시에 취소.
3. **보안 (Security)**
    - **접근 권한**을 설정하여 데이터에 대한 **무단 접근**을 방지한다.
    - 예: 관리자만 고객의 개인정보에 접근할 수 있도록 제한.

---

## 데이터베이스 관리 시스템(DBMS)의 역할과 구조

**정보 시스템**

- **정의**:
    - 조직 운영에 필요한 데이터를 수집하여 저장해두었다가 의사 결정이 필요할 때 처리하여 유용한 데이터를 만들어주는 수단
    
    ![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%201.png)
    

**DBMS**

- **정의**:
    - 데이터베이스를 관리하고, 데이터를 저장·검색·삽입·수정·삭제할 수 있는 기능을 제공하는 시스템이다.
- **역할**:
    - 정보 시스템의 **핵심** 역할을 담당하며, 데이터를 통합 저장하고 필요 시 제공한다.
    - 응용 프로그램 대신 데이터베이스의 데이터를 **관리**하고, 여러 프로그램이 데이터를 **공유**해 사용할 수 있도록 지원한다.
- **구조**:
    
    ![DBMS가 사용자와 데이터베이스 사이에서 어떻게 데이터를 관리하고 제공하는지 시각적으로 표현한 그림이다. 사용자는 응용 프로그램을 통해 DBMS와 상호작용하며, DBMS는 데이터를 효율적으로 처리하여 사용자에게 제공한다. DBMS 구조는 이 과정에서 데이터를 추상화하여 사용자에게 복잡성을 숨긴다](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.58.36.png)
    
    DBMS가 사용자와 데이터베이스 사이에서 어떻게 데이터를 관리하고 제공하는지 시각적으로 표현한 그림이다. 사용자는 응용 프로그램을 통해 DBMS와 상호작용하며, DBMS는 데이터를 효율적으로 처리하여 사용자에게 제공한다. DBMS 구조는 이 과정에서 데이터를 추상화하여 사용자에게 복잡성을 숨긴다
    
    - **외부 계층**:
        - 사용자와 응용 프로그램이 위치하며, 고객 관리 및 주문 관리와 같은 응용 프로그램이 데이터를 조회하거나 수정한다.
    - **개념 계층**:
        - DBMS가 위치하며, 사용자 요청을 해석하고 데이터를 처리하는 계층이다. 데이터를 논리적으로 관리하며, 사용자에게 데이터의 물리적 세부사항을 숨긴다.
    - **내부 계층**:
        - 데이터베이스 자체가 포함되며, 실제 데이터가 저장된 물리적 구조와 저장 방식을 담당한다.
- **주요 기능:**
    - **정의 기능**: 데이터베이스의 구조를 정의하거나 수정할 수 있다.
    - **조작 기능**: 데이터를 삽입, 삭제, 수정, 검색하는 연산을 할 수 있다.
    - **제어 기능**: 데이터 항상 정확하고 안전하게 유지할 수 있다.
- **장점:**
    - **데이터 중복 통제**: 데이터를 통합 관리하여 중복을 줄인다.
    - **데이터 독립성 확보**: 데이터 구조 변경 시 응용 프로그램에 영향이 없다.
    - **동시성 지원**: 여러 사용자가 데이터를 동시에 접근할 수 있다.
    - **보안 및 무결성 유지**: 데이터 접근 권한과 무결성을 보장한다.
    - **표준화**: 데이터의 관리와 처리 표준을 제공한다.
    - **장애 발생 시 회복 가능**: 장애 복구 기능으로 데이터 복원 가능.
    - **응용 프로그램 개발 비용 절감**: 데이터 관리 기능을 제공하여 개발 효율성이 높다.
- **단점:**
    - **개발 비용이 높음**: 데이터베이스 설계 및 구축 비용이 크다.
    - **장애 발생 시 복잡성 증가**: 데이터 양이 많아 장애 발생 시 원인과 상태 파악이 어렵다.
    - **통합된 시스템의 위험성**: 모든 데이터가 통합되므로 DBMS 장애 시 전체 시스템에 문제가 발생할 수 있다.

---

## 데이터베이스 모델의 종류

> 데이터베이스 모델은 **관계형 데이터베이스**와 **비관계형 데이터베이스**로 분류된다.
> 

| SQL | NoSQL |
| --- | --- |
| **관계형** 데이터베이스 관리 시스템 | **비관계형** 데이터베이스 관리 시스템 |
| 미리 정의된 스키마가 있는 **구조화된 데이터**가 적합 | **비정형 및 반정형 데이터**에 적합 |
| 행과 열이 있는 **테이블**에 저장 | **컬렉션 또는 문서**에 저장 |
| 대량의 데이터를 처리하기 위해 **수직 확장**이 필요 | **수평 확장**을 통해 대량의 데이터를 처리 가능 |
| **정규화**된 데이터 구조 사용 | **비정규화**된 데이터 구조 사용 |

### 관계형 데이터베이스 (Relational Database)

> SQL (Structured Query Language)
> 
- **정의**:
    - 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 **저장**, **수정**, **삭제**, **검색**할 수 있도록 돕는 **언어**.
- **특징:**
    - 데이터는 **정해진 데이터 스키마**에 따라 **테이블**에 저장된다.
    - 데이터는 **관계**를 통해 여러 테이블에 분산된다.
- **장점:**
    - 데이터 무결성 보장하고 명확한 데이터 구조로 데이터 관리가 용이하다.
    - 복잡한 질의(Query)와 데이터 연산이 가능하다.
- **예시:**
    - MySQL, PostgreSQL, Oracle, SQL Server, Microsoft SQL Server
- **SQL 데이터베이스 사용이 적합한 경우:**
    - 데이터가 **관계형** 구조로 이루어져 있고, **자주 변경**되는 어플리케이션.
    - **변경 가능성이 낮고 명확한 스키마**가 사용자와 데이터 관리에 중요한 경우.

### 비관계형 데이터베이스 (NoSQL)

> NoSQL (Not Only SQL)
> 
- **정의**:
    - 관계형 데이터베이스와 달리 **스키마가 없고, 관계를 정의하지 않는** 데이터베이스.
- **특징**:
    - **레코드** → **문서 (Document)**
        - 데이터를 JSON과 유사한 **문서 형태**로 저장.
        - 여러 테이블로 나누지 않고, 관련 데이터를 하나의 **컬렉션(Collection)** 에 담는다.
    - **테이블** → **컬렉션 (Collection)**
        - **다른 구조**의 데이터를 동일한 컬렉션에 추가 가능.
- **장점:**
    - **유연한 데이터 구조**:변경 가능성이 높은 데이터를 효과적으로 처리.
    - **빠른 읽기/쓰기 속도**:복잡한 관계 설정 없이 단일 컬렉션에서 데이터 처리.
    - **수평 확장성**:막대한 양의 데이터를 처리할 때 유리.
- **예시:**
    - MongoDB, Cassandra, Couchbase, Amazon DynamoDB, Redis
- **NoSQL 데이터베이스가 적합한 경우:**
    - 데이터 구조를 **사전에 정의할 수 없거나**, 자주 변경/확장될 가능성이 있는 경우.
    - 읽기 작업이 많고, **데이터 변경이 적은** 경우.
    - 데이터베이스를 **수평으로 확장**해야 하는 경우: 대규모 데이터 처리에 효과적.
- 주의사항:
    - **데이터 중복**: 데이터가 여러 컬렉션에 중복 저장되므로, 데이터 변경 시 **모든 컬렉션에서 업데이트** 필요.
    - **조인(Join) 사용 제한:** 조인을 지원하지 않으므로, 데이터 처리 시 별도의 구조 설계가 필요.

### 계층형, 네트워크형 모델

**계층형 데이터 모델 (Hierㅇarchical Data Model)**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%202.png)

- **정의**:
    
    데이터를 **트리(Tree) 구조**로 조직화하여, 부모-자식 관계로 데이터를 표현하는 데이터 모델이다.
    
- **특징**:
    1. 각 부모 노드는 하나 이상의 자식 노드를 가질 수 있지만, 자식 노드는 하나의 부모 노드만 가질 수 있다.
    2. 데이터 간의 **1:N 관계**를 표현하기 적합하다.
    3. 데이터 접근은 상위 레벨에서 하위 레벨로 진행되며, 계층 구조를 따라야 한다.
- **장점**:
    - 데이터가 **논리적이고 직관적**으로 조직화된다.
    - 부모-자식 관계가 명확하여 데이터 검색이 빠르다.
- **단점**:
    - **유연성이 부족**하여 데이터 구조 변경이 어렵다.
    - 데이터 간 복잡한 관계를 표현하기 어렵다.
    - 부모 노드가 삭제되면 해당 자식 노드도 삭제될 수 있다.
- **예시**:
    - 조직도, 파일 디렉토리 구조 등.

**네트워크형 데이터 모델 (Network Data Model)**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%203.png)

- **정의**:
    
    데이터를 **그래프(Graph) 구조**로 표현하여, 하나의 데이터 항목이 여러 데이터 항목과 연결될 수 있는 데이터 모델이다.
    
- **특징**:
    1. 데이터를 노드(Node)와 간선(Edge)로 표현하며, **다대다(M:N) 관계**를 표현할 수 있다.
    2. 레코드 간의 관계를 **네트워크 형태**로 저장하여 복잡한 데이터 구조를 처리할 수 있다.
    3. 데이터 접근은 경로 기반으로 이루어진다.
- **장점**:
    - 복잡한 데이터 구조를 표현할 수 있다.
    - 데이터 중복을 줄이고, 관계 간의 연결성을 높인다.
- **단점**:
    - 구조가 복잡하여 설계와 관리가 어렵다.
    - 데이터에 접근하려면 정확한 경로를 알아야 하므로, 사용이 어렵다.
- **예**:
    
    항공 노선 데이터, 통신망 데이터 등.
    

**비교**

| **구분** | **계층형 모델** | **네트워크형 모델** |
| --- | --- | --- |
| **구조** | 트리 구조 | 그래프 구조 |
| **관계 표현** | 1:N 관계 | M:N 관계 |
| **장점** | 데이터 검색 속도가 빠름 | 복잡한 관계 표현 가능 |
| **단점** | 유연성이 부족하고 관계 표현이 제한적임 | 설계 및 관리가 복잡하고 사용이 어려움 |

---

# 데이터 모델링

---

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%204.png)

## 데이터 모델링 개념과 프로세스

**데이터 모델링**

- **정의**:
    - 현실 세계의 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 **변환 과정**으로, 데이터베이스 설계의 핵심 과정이다.

**주요 개념**

- **추상화 (Abstraction)**:
    - 데이터베이스에 저장하여 관리할 만한 **가치가 있는 중요 데이터를 추출**하는 것.
- **개념적 모델링 (Conceptual Modeling)**:
    - 현실 세계에서 중요한 데이터를 추출하여 **개념 세계로 옮기는 작업**.
- **논리적 모델링 (Logical Modeling)**:
    - 개념 세계의 데이터를 데이터베이스에 저장할 **구조를 결정하고 표현**하는 작업.

## ER(Entity-Relationship) 다이어그램

**ER 다이어그램 (Entity-Relationship Diagram)**

- **정의:**
    - **현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)으로 나누어 시각적으로 표현**한 다이어그램으로, 데이터베이스 설계의 초기 단계에서 사용된다.
        
        ![스크린샷 2025-01-10 오전 10.37.21.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.37.21.png)
        
- **필요성:**
    - **데이터 구조의 명확화**
    - **의사소통 도구**
    - **데이터 중복 및 비효율 제거**
    - **데이터베이스 설계의 초석**
    - **요구사항 반영**
- **사용 예시:**
    - 병원의 환자 관리 시스템, 대학의 학사 관리 시스템 등

### 엔터티, 속성, 관계

**기본 구성 요소**

![스크린샷 2025-01-10 오전 3.10.25.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_3.10.25.png)

1. **개체(Entity):**
    - **정의:** 현실 세계에서 저장할 가치가 있는 데이터를 지닌 사람, 사물, 개념, 사건 등을 의미.
    - **표기법:** 사각형
    - **특징:**
        - **개체 타입:** 고유 이름과 속성들로 정의한 것
        - **개체 인스턴스:** 속성 값이 실체화된 개체
        - **개체 집합:** 여러 개체 인스턴스들의 집합
    - **예시:** 대학교의 학과
2. **속성(Attribute):**
    - **정의:** 개체의 고유한 특성을 나타내는 데이터.
    - **표기법:** 타원
        - **키 속성:** 밑줄
        - **다중 값 속성:** 이중 타원
        - **유도 속성:** 점선 타원
    - **분류:**
        - **단일/다중 값 속성:**
            - 단일 값: 하나의 값만 가짐 (예: 고객 이름).
            - 다중 값: 여러 개의 값을 가짐 (예: 연락처).
        - **단순/복합 속성:**
            - 단순: 더 이상 분해 불가 (예: 생일).
            - 복합: 여러 속성으로 구성됨 (예: 주소: 시, 도, 우편번호).
        - **유도 속성:** 다른 속성 값에서 유도됨 (예: 총 금액 = 단가 × 수량).
        - **널 속성:** 값이 없을 수도 있음 (예: 병역 상태).
3. **관계(Relationship):**
    - **정의:** 개체들 간의 의미 있는 연관성을 표현.
    - **표기법:** 마름모
    - **특징:**
        - 관계도 속성을 가질 수 있음 (예: 구매 관계의 구매일자).
        - 개체 간 매핑 카디널리티(Cardinality)를 정의.
    - **관계 유형:**
        - **이항 관계:** 두 개체 간의 관계.
        - **삼항 관계:** 세 개체 간의 관계.
        - **순환 관계:** 한 개체가 자기 자신과 관계를 맺음.
    - **매핑 카디널리티:**
        - **1:1 관계:** 한 개체가 다른 개체와 1:1로 연결 (예: 혼인 관계).
        - **1:N 관계:** 한 개체가 여러 개체와 연결되나, 반대는 불가 (예: 부서-사원).
        - **N:M 관계:** 양쪽 모두 여러 개체와 연결 가능 (예: 학생-강의).

---

## 정규화

- **정의**:
    
    정규화는 데이터베이스에서 **중복을 제거**하고 **데이터 무결성을 유지**하기 위해 데이터를 체계적으로 정리하는 과정이다.
    
    데이터를 효율적으로 저장하고 유지보수하기 위한 중요한 설계 기법이다.
    
- **장점**:
    - 데이터의 중복 제거
    - 데이터 무결성 유지
    - 갱신 이상(삽입, 삭제, 수정 이상) 방지
    - 효과적인 검색 알고리즘 생성
- **단점:**
    - Join 연산 증가로 응답 시간이 저하

**정규화 단계**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%205.png)

### 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF)

**제1정규형 (1NF)**

- **정의**:
    - 모든 속성이 원자값(Atomic Value)을 가져야 한다. 즉, 데이터는 더 이상 쪼갤 수 없는 값으로 구성되어야 한다.
- **조건**:
    1. 각 필드에는 하나의 값만 존재해야 함.
    2. 반복되는 속성이나 그룹화된 데이터가 없어야 함.
- **예시**:
    - 비정규형: `고객 이름 | 연락처 (집, 휴대폰)`
    - 1NF: `고객 이름 | 집 연락처 | 휴대폰 연락처`

**제2정규형 (2NF)**

- **정의**:
    - 제1정규형을 만족하면서 **부분 함수 종속**을 제거한다.(기본키의 일부가 아닌 속성이 기본키 전체에 종속되어야 함.)
- **조건**:
    1. 제1정규형을 만족해야 함.
    2. 기본키의 일부에만 종속된 속성을 제거하고, 별도의 테이블로 분리.
- **예시**:
    - 비정규형: `학생ID, 과목코드 → 성적`, `과목 → 교수`
    - 2NF:
        1. `학생ID, 과목 → 성적`
            
            ![과목명만 있으면 지도교수를 알 수 있다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%206.png)
            
            과목명만 있으면 지도교수를 알 수 있다.
            
        2. `과목 → 교수`
            
            ![제 2 정규화를 통해 다음과 같이 분리하였다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%207.png)
            
            제 2 정규화를 통해 다음과 같이 분리하였다.
            

**제3정규형 (3NF)**

- **정의**: 제2정규형을 만족하면서 **이행적 함수 종속**을 제거한다.(비기본 속성이 다른 비기본 속성에 종속되지 않아야 함.)
- **조건**:
    1. 제2정규형을 만족해야 함.
    2. 비기본키 속성이 다른 비기본키 속성에 종속되지 않아야 함.
- **예시**:
    - 비정규형: `ID → 등급`, `등급 → 할인율`, `ID → 할인율`
        
        ![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%208.png)
        
    - 3NF:
        1. `ID → 등급`
        2. `등급 -> 할인율`
        
        ![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%209.png)
        

### BCNF와 다섯 번째 정규형(5NF)

**BCNF (Boyce-Codd Normal Form)**

- **정의**:
    - 제3정규형을 강화한 형태로, 모든 결정자가 **후보키**여야 한다.
        - 제3정규형에서 기본키 이외의 속성에 의해 종속이 발생하는 경우를 해결.
- **예시**:
    - 비정규형:
        - `학생번호, 과목 →  지도교수`
        - `지도교수 → 과목`
        
        ![지도교수 → 과목이 종속적이다. ](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2010.png)
        
        지도교수 → 과목이 종속적이다. 
        
    - BCNF:
        - `학생번호 → 지도교수`
        - `지도교수 → 과목`
        
        ![다음과 같이 분리하면 된다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2011.png)
        
        다음과 같이 분리하면 된다.
        

**다섯 번째 정규형 (5NF)**

- **정의**: 다치 종속(Multi-Valued Dependency)을 제거하여 데이터베이스를 완전히 분해한 상태.
    - **다치 종속**: 같은 테이블 내의 독립적인 두 개 이상의 컬럼이 또 다른 컬럼에 종속되는 것을 말한다.
        - 즉, A → B 인 의존성에서 단일 값 A와 다중 값 B가 존재한다면 다치 종속이라고 할 수 있다. 이러한 종속을 A ↠ B 로 표기한다. (다치 종속은 이중 화살표(double arrow) ↠ 로 표기한다.)
- **조건**:
    - 모든 조인이 자연 조인이어야 하며, 데이터의 손실 없이 복원 가능해야 함.
- **목적**: 복잡한 종속성을 제거하여 데이터를 최대한 단순화.

---

## 비정규화와 성능 최적화

**비정규화 (Denormalization)**

- **정의**: 정규화된 데이터베이스를 성능 최적화와 특정 요구사항에 따라 **일부러 중복을 허용**하여 정규화를 역행하는 과정.
- **장점**:
    - 빠른 데이터 조회(Join 비용 감소).
    - 데이터 조회 쿼리의 간단화.
- **단점**:
    - 데이터 갱신이나 삽입 비용이 높음.
    - 데이터 무결성을 해침.
    - 데이터 중복 저장으로 인한 추가 저장공간 확보 필요.

**성능 최적화**

- **방법:**
    - 성능 최적화를 위해 정규화와 비정규화를 상황에 따라 적절히 활용하며, 데이터 조회 빈도와 데이터 무결성 요구 사항을 균형 있게 고려해야 한다.
- **정규화가 적합한 상황**:
    - **정규화**는 데이터 **무결성**과 **변경 관리**가 중요한 경우.
- **비정규화가 적합한 상황**:
    - **비정규화**는 **조회 성능**과 **운영 효율성**이 중요한 경우.

---

# 관계형 데이터베이스

---

## 관계형 데이터베이스의 개념

![릴레이션 예시](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2012.png)

릴레이션 예시

- **정의**
    - 관계형 데이터베이스(Relational Database)는 **테이블(릴레이션)** 형태로 데이터를 저장하는 데이터베이스로, 데이터를 행(튜플)과 열(속성)로 구성하여 저장한다.
- **특징**
    - 데이터를 **정규화**하여 중복을 최소화하고 무결성을 유지.
    - SQL(Structured Query Language)을 사용하여 데이터를 정의, 조회, 삽입, 수정, 삭제.
    - 데이터 간의 관계를 키(key)를 통해 표현.
- **관련 용어**
    - **속성**
        - 릴레이션의 열
    - **투플:** 릴레이션의 행
    - **도메인:** 속성 하나가 가질 수 있는 모든 값의 집합
    - **차수:** 하나의 릴레이션에서 속성 전체의 개수
    - **카디널리티:** 하나의 릴레이션에서 투플 전체 개수
- **장점**
    - 데이터 무결성과 일관성 보장.
    - 데이터 중복 최소화.
    - 복잡한 질의(Query) 처리 가능.

---

## 키의 종류

### 기본 키

- **정의**
    - 테이블 내의 각 튜플을 **유일하게 식별**할 수 있는 속성 또는 속성의 조합.
    - 하나의 테이블에는 **단 하나의 기본 키**만 존재.
- **특징**
    - 중복된 값 허용 불가.
    - NULL 값 허용 불가.

### 후보 키

- **정의**
    - 테이블에서 기본 키로 지정할 수 있는 **후보 속성 집합**.
    - 유일성과 최소성을 만족하는 속성.
- **특징**
    - 기본 키는 후보 키 중 하나를 선택.
    - 여러 후보 키가 존재할 수 있음.

### 외래 키

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2013.png)

- **정의**
    - 한 테이블의 속성이 **다른 테이블의 기본 키를 참조**하는 키.
    - 두 테이블 간의 관계를 정의.
- **특징**
    - 데이터 무결성을 유지하도록 **참조 무결성 제약 조건**을 적용.
    - 외래 키 값은 참조되는 기본 키의 값과 같거나 NULL이어야 함.

---

## 릴레이션 연산

### **셀렉션(Selection)**

- **정의**
    - 릴레이션에서 특정 조건을 만족하는 **행(튜플)**만 선택하는 연산.
        
        ![스크린샷 2025-01-10 오전 11.15.57.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.15.57.png)
        
- **기호**: σ
- **예시**:
    
    ```sql
    SELECT * FROM 학생 WHERE 학년 = 3;
    ```
    

---

### **프로젝션(Projection)**

![스크린샷 2025-01-10 오전 11.16.07.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.16.07.png)

- **정의**
    - 릴레이션에서 특정한 **열(속성)**만 선택하여 새로운 릴레이션을 생성하는 연산.
- **기호**: π
- **예시**:
    
    ```sql
    SELECT 이름, 학과 FROM 학생;
    ```
    

---

### **조인(Join)**

- **정의**
    
    ![스크린샷 2025-01-10 오전 11.16.13.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.16.13.png)
    
    - 두 릴레이션의 공통 속성을 기준으로 **연결**하여 새로운 릴레이션을 생성하는 연산.
- **종류**:
    1. 내부 조인 (Inner Join)
    2. 외부 조인 (Outer Join: Left, Right, Full)
    3. 교차 조인 (Cross Join)
- **예시**:
    
    ```sql
    SELECT 학생.이름, 수강.과목명
    FROM 학생
    JOIN 수강 ON 학생.학번 = 수강.학번;
    ```
    

---

### 집합 연산(Union, Intersection, Difference)

**Union (합집합)**

![스크린샷 2025-01-10 오전 11.16.45.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.16.45.png)

- **정의**
    - 두 릴레이션의 **모든 튜플**을 결합하며, 중복된 튜플은 제거.
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    **UNION**
    SELECT 학번 FROM 학생2;
    ```
    

---

**Intersection (교집합)**

![스크린샷 2025-01-10 오전 11.16.55.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.16.55.png)

- **정의**
    - 두 릴레이션에서 **공통으로 존재**하는 튜플만 선택.
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    **INTERSECT**
    SELECT 학번 FROM 학생2;
    ```
    

---

**Difference (차집합)**

![스크린샷 2025-01-10 오전 11.17.02.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.17.02.png)

- **정의**
    - 첫 번째 릴레이션에 존재하지만 두 번째 릴레이션에는 없는 튜플만 선택.
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    **EXCEPT**
    SELECT 학번 FROM 학생2;
    ```
    

---

# SQL

---

## SQL의 개요와 구성

- **정의**
    
    SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 **정의, 조작, 제어**하는 데 사용되는 표준 언어이다.
    
- **구성 요소**
    - **DDL** (Data Definition Language): 데이터베이스 구조 정의.
    - **DML** (Data Manipulation Language): 데이터의 삽입, 조회, 수정, 삭제 수행.
    - **DCL** (Data Control Language): 데이터베이스 접근 권한 관리.
    - **TCL**(Transaction Control Language): 데이터베이스에서 **트랜잭션**의 실행을 제어.

![Untitled](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/Untitled.png)

---

## 데이터 정의 언어(DDL)

### CREATE, ALTER, DROP

**`CREATE`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체를 정의한다.
- **예시**
    
    ```sql
    CREATE TABLE 학생 (
      학번 INT PRIMARY KEY,
      이름 VARCHAR(50),
      학과 VARCHAR(50)
    );
    ```
    

**`ALTER`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체 정의를 변경한다.
- **예시**
    
    ```sql
    ALTER TABLE 학생 ADD 생년월일 DATE;
    ALTER TABLE 학생 MODIFY 이름 VARCHAR(100);
    ```
    

**`DROP`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체를 삭제한다.
- **예시**
    
    ```sql
    DROP TABLE 학생;
    ```
    

---

## 데이터 조작 언어(DML)

### SELECT, INSERT, UPDATE, DELETE

**`SELECT`**

- **정의**
    - 테이블에 저장된 데이터를 조건에 맞게 조회한다.
- **예시**
    
    ```sql
    SELECT 이름, 학과 FROM 학생 WHERE 학년 = 3;
    ```
    

**`INSERT`**

- **정의**
    - 테이블에 새로운 데이터를 추가한다.
- **예시**
    
    ```sql
    INSERT INTO 학생 (학번, 이름, 학과) VALUES (20210101, '김철수', '컴퓨터공학');
    ```
    

**`UPDATE`**

- **정의**
    - 테이블에 저장된 데이터를 수정한다.
- **예시**
    
    ```sql
    UPDATE 학생 SET 학과 = '정보통신공학' WHERE 학번 = 20210101;
    ```
    

**`DELETE`**

- **정의**
    - 테이블에 저장된 데이터(튜플)을 삭제한다.
- **예시**
    
    ```sql
    DELETE FROM 학생 WHERE 학번 = 20210101;
    ```
    

### JOIN과 서브쿼리

- **`JOIN`**: 두 개 이상의 테이블을 연결하여 데이터를 조회.
    - **예시**
        
        ```sql
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        JOIN 수강 ON 학생.학번 = 수강.학번;
        ```
        
- **서브쿼리**: 하나의 쿼리 내에서 또 다른 쿼리를 사용하는 방식.
    - **예시**
        
        ```sql
        SELECT 이름
        FROM 학생
        WHERE 학번 IN (
          SELECT 학번
          FROM 수강
          WHERE 과목명 = '데이터베이스'
        );
        
        ```
        

## 데이터 제어 언어(DCL)

### GRANT, REVOKE

**`GRANT`**

- **정의**
    - 특정 사용자에게 데이터베이스 객체에 대한 **권한을 부여**.
- **예시**
    
    ```sql
    GRANT SELECT, INSERT ON 학생 TO user1;
    ```
    

**`REVOKE`**

- **정의**
특정 사용자에게 부여된 권한을 **철회**.
- **예시**
    
    ```sql
    REVOKE SELECT ON 학생 FROM user1;
    ```
    

---

## 트랜잭션 제어 언어(TCL)

### COMMIT, ROLLBACK, SAVEPOINT

**`COMMIT`**

![스크린샷 2025-01-10 오전 11.28.23.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.28.23.png)

- **정의**
    - 현재 트랜잭션에서 수행된 변경 사항을 **영구적으로 저장**.
- **예시**
    
    ```sql
    COMMIT;
    ```
    

**`ROLLBACK`**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2014.png)

- **정의**
    - 현재 트랜잭션에서 수행된 변경 사항을 **취소**하고 이전 상태로 되돌림.
- **예시**
    
    ```sql
    ROLLBACK;
    ```
    

**`SAVEPOINT`**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2015.png)

- **정의**
    - 트랜잭션 내 특정 지점을 저장하여, 필요 시 해당 지점으로 **부분적으로 롤백** 가능.
- **예시**
    
    ```sql
    SAVEPOINT 저장점1;
    ROLLBACK TO 저장점1;
    ```
    

---

# 트랜잭션과 동시성 제어

---

## 트랜잭션의 개념

- **정의:**
    - 데이터베이스에서 수행되는 **하나의 작업 단위**로, 논리적으로 묶여 있는 일련의 연산을 의미한다.
        - 트랜잭션은 데이터베이스의 **일관성**을 유지하기 위해 사용된다.
        - 예시: 은행 계좌에서 이체하는 과정(출금과 입금)이 하나의 트랜잭션.
- **목적:**
    - 데이터 부정합 방지
        - 예시: 데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우
    - 데이터베이스의 완전성 유지 확신
        - 예시: 송금시 한 계좌에서 인출 시 다른 계좌에서 입금 확인
    - 거래의 안전성 확보
        - 예시: 테이블에서 데이터를 읽어오고 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생 시 모든 작업을 원상태로 되돌려야 한다. 처리 과정 모두 성공 시에만 최종적으로 데이터베이스에 반영한다.
            
            ![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2016.png)
            

---

## 트랜잭션 특성 (ACID)

- **Atomicity (원자성)**
    - 트랜잭션 내의 작업이 모두 성공하거나 모두 실패해야 한다.
        - 부분적인 변경은 허용되지 않음.
- **Consistency (일관성)**
    - 트랜잭션 수행 전후에 데이터베이스가 **일관된 상태**를 유지해야 한다.
- **Isolation (고립성)**
    - 여러 트랜잭션이 동시에 수행되더라도 서로 간섭하지 않아야 한다.
- **Durability (지속성)**
    - 트랜잭션이 성공적으로 완료된 경우, 그 결과는 영구적으로 반영되어야 한다.

---

## 동시성 문제

### 갱신 손실, 비일관성 읽기, 비반복 읽기

**갱신 손실 (Lost Update)**

- **정의:**
    - 두 트랜잭션이 동시에 동일 데이터를 수정하여 한 트랜잭션의 변경 내용이 **손실**되는 문제.
- **예시:**
    - 두 사용자가 동시에 상품 재고를 수정하면 한 사용자의 변경이 덮어씌워짐.

**비일관성 읽기 (Dirty Read)**

- **정의:**
    - 한 트랜잭션이 다른 트랜잭션에서 아직 **커밋되지 않은 데이터를 읽는 경우** 발생.
- **결과:**
    - 읽은 데이터가 롤백되면 **잘못된 데이터를 기반**으로 작업이 수행됨.

**비반복 읽기 (Non-Repeatable Read)**

- **정의:**
    - 같은 트랜잭션 내에서 동일 데이터를 **여러 번 읽을 때 값이 달라지는 문제**.
- **결과:**
    - 다른 트랜잭션이 데이터를 수정하거나 삭제했을 때 발생.

---

## 트랜잭션 격리 수준

- 정의:
    - 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할 지 말 지 결정하는 것

### Read Uncommitted, Read Committed, Repeatable Read, Serializable

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2017.png)

**Read Uncommitted**

- **특징**: 어떤 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여짐.
- **문제점**: Dirty Read 발생 가능.
- **사용 시기**: 데이터 무결성이 중요하지 않을 때.

**Read Committed**

- **특징**: 어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회 가능.
- **문제점**: Non-Repeatable Read 발생 가능.
- **사용 시기**: 대부분의 애플리케이션에서 기본 격리 수준.

**Repeatable Read**

- **특징**: 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능.
- **문제점**: Phantom Read 발생 가능.
- **사용 시기**: 일관된 데이터 읽기가 필요한 경우.

**Serializable**

- **특징**: 트랜잭션이 특정 테이블을 조회하면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제 불가능. 트랜잭션 간 **완전한 고립**을 보장.
- **문제점**: 성능 저하.
- **사용 시기**: 무결성이 절대적으로 중요한 경우.

---

## 동시성 제어 기법

### 잠금(Locking)과 타임스탬프

**잠금(Locking)**

- **정의:**
    - 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
- **특징:**
    - 로킹 단위(한 번에 로킹할 수 있는 데이터의 크기) 크기에 따라 성능 차이가 발생한다.
        - **로킹 단위가 클수록**: 병행 제어가 단순하지만 병행성 수준이 낮아짐.
        - **로킹 단위가 작을수록**: 병행 제어는 복잡하지만 병행성과 데이터 공유도가 높아짐
    - 로킹 규약:
        - 데이터를 사용하려면 `lock` 수행.
        - 사용 후 반드시 `unlock` 수행.
        - 이미 잠긴 데이터에는 다른 트랜잭션이 접근 불가.
        - 다른 트랜잭션이 잠근 데이터는 해제 불가.
- **종류:**
    - **공유 잠금 (Shared Lock)**: 데이터 읽기만 가능, 다른 트랜잭션의 쓰기 불가.
    - **배타 잠금 (Exclusive Lock)**: 데이터 읽기와 쓰기 모두 불가.
- **장점:**
    - 데이터 무결성과 일관성 보장.
    - 병행 제어 제공.
    - 구현이 비교적 단순.
- **단점:**
    - 읽기 전용 작업에도 효율적이지 못함.
    - 교착 상태(Deadlock) 발생 가능.
        - 서로 다른 트랜잭션이 서로 잠근 데이터에 접근하려다 무한정 대기하는 상황

![트랜잭션 T1에서 x를 lock 하고 T2에서 y를 lock 한 경우에 T1도 y에 접근할 수 없고 T2도 x에 접근할 수 없다. 따라서 서로 무한정 기다리게 된다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2018.png)

트랜잭션 T1에서 x를 lock 하고 T2에서 y를 lock 한 경우에 T1도 y에 접근할 수 없고 T2도 x에 접근할 수 없다. 따라서 서로 무한정 기다리게 된다.

**2단계 로킹 규약**

- **정의**:
    - 각 트랜잭션의 lock과 unlock 요청을 확장 단계(Growing phase)와 축소 단계(Shrinking phase)로 나누어 처리하는 방식이다.
- **단계**:
    1. **확장 단계 (Growing Phase)**: 새로운 lock은 수행 가능하지만 unlock은 불가.
    2. **축소 단계 (Shrinking Phase)**: unlock은 수행 가능하지만 lock은 불가.
- **특징**:
    
    모든 lock 연산이 첫 unlock 연산 이전에 위치하여 직렬성을 보장한다.
    
    - 트랜잭션이 데이터를 완전히 연산한 후 unlock을 수행한다.
- **장점:**
    - 직렬성을 보장한다.
    - 그 외 로킹과 동일한 장점을 가진다.
- **단점:**
    - 교착 상태 문제를 완전히 해결하지는 못한다.

![왼쪽은 2단계 로킹 규약을 만족하는 예이고 오른쪽은 만족하지 않는 예이다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2019.png)

왼쪽은 2단계 로킹 규약을 만족하는 예이고 오른쪽은 만족하지 않는 예이다.

**타임스탬프(Timestamp)**

- **정의:**
    - 비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법.
- **특징:**
    - **타임스탬프 생성 방법:**
        - **논리적 계수기**: 트랜잭션이 들어올 때마다 카운터를 1씩 증가시켜 타임스태프를 생성한다.
        - **시스템 클럭**: 시스템 고유 시계를 사용해 타임스탬프를 생성한다.
    - **운영 방식:**
        - **read_TS(x)**:`read(x)` 연산을 성공적으로 수행한 트랜잭션들의 가장 큰 타임스탬프.
        - **write_TS(x)**:`write(x)` 연산을 성공적으로 수행한 트랜잭션들의 가장 큰 타임스탬프.
        
        **1)  `read(x)` 수행 조건**
        
        - `TS(T) < write_TS(x)`:`read(x)`를 거부하고 트랜잭션 T를 취소 후 Rollback 수행.
        - `TS(T) ≥ write_TS(x)`:`read(x)`를 허용하고 `read_TS(x)`를 `TS(T)`로 갱신.
        
        **2) `write(x)` 수행 조건**
        
        - `TS(T) < read_TS(x)`:`write(x)`를 거부하고 트랜잭션 T를 취소 후 Rollback 수행.
        - `TS(T) < write_TS(x)`:**Thomas Write Rule**을 적용하여 `write(x)`를 무시해 트랜잭션 취소를 줄인다.
        - 이외의 경우:`write(x)`를 허용하고 `write_TS(x)`를 `TS(T)`로 갱신.
- **장점**:
    - Lock을 사용하지 않으므로 교착상태가 발생하지 않는다.
    - 직렬성을 보장한다.
- **단점:**
    - Rollback 발생률이 높다.
    - 연쇄 복귀를 초래할 가능성이 있다.

---

# 데이터베이스 설계

---

## 데이터베이스 설계 단계

![데이터베이스를 설계하는 과정은 총 5단계로 구성된다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/b723b129-5043-4a88-bca5-5441a17abad1.png)

데이터베이스를 설계하는 과정은 총 5단계로 구성된다.

### 요구사항 분석

- **정의:**
    - 데이터베이스 설계의 첫 단계로, 사용자 및 시스템 요구사항을 분석하여 데이터베이스에 저장할 **데이터와 관계**를 정의한다.
- **활동**
    - 주요 엔터티와 속성 도출
    - 사용자 시나리오 및 데이터 흐름 분석
    - 시스템 성능 및 데이터 처리 요구사항 정의

### 논리적 설계

- **정의:**
    - 요구사항 분석을 기반으로 **개념적 모델**을 데이터베이스에 맞게 변환하는 과정.
- **활동**
    - 데이터 모델링 (ER 다이어그램)
    - 정규화 과정 수행
    - 릴레이션 스키마 도출
- **결과물**:
    - 데이터베이스의 구조를 논리적으로 표현 (ex: 테이블, 속성, 관계).

### 물리적 설계

- **정의:**
    - 논리적 설계를 물리적 데이터베이스로 구현하기 위해 **저장 방식과 최적화 방법**을 설계하는 단계.
- **활동**
    - 저장소 선택 (SSD, HDD 등)
    - 인덱스 설계 및 최적화
    - 파티셔닝 및 데이터 분산 설계
- **결과물**:
    - 최적화된 데이터베이스 구현을 위한 구체적인 설계.

---

## 스키마 설계

### 개념 스키마, 논리 스키마, 물리 스키마

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2020.png)

**개념 스키마**

- **정의:**
    - 데이터베이스의 전반적인 논리적 구조를 표현하며, **사용자와 데이터베이스 시스템 간의 인터페이스** 역할.
- **특징**
    - 데이터의 의미와 제약조건 포함.
    - ER 다이어그램과 같은 개념적 모델을 사용.

**논리 스키마**

- **정의:**
    - 데이터베이스의 구조를 **특정 데이터베이스 관리 시스템(DBMS)에 독립적**으로 설계한 스키마.
- **특징**
    - 릴레이션, 속성, 키 정의.
    - 정규화를 통해 설계 최적화.

**물리 스키마**

- **정의:**
    - 논리 스키마를 **저장 장치에 물리적으로 구현**한 구조.
- **특징**
    - 데이터 저장 방식, 인덱스 설정, 파티셔닝 등을 포함.
    - DBMS와 스토리지 환경에 따라 달라질 수 있음.

---

## 인덱스 설계

**인덱스**

- **정의:**
    - 데이터 레코드를 빠르게 접근하기 위해서 <키, 포인터>쌍으로 구성되는 데이터 구조.
- **특징:**
    - PK값과 해당하는 데이터 row의 주소를 자료구조로 묶어서 저장.
- **장점:**
    - DB의 테이블에 데이터가 많을 때, 검색 속도를 향상시킨다.
- **단점:**
    - 인덱스를 위한 디스크 공간이 필요하다.
    - 인덱스를 가진 테이블에 DML 작업 시 더 많은 비용과 시간이 필요하다.

### 클러스터드 인덱스와 비클러스터드 인덱스

> 인덱스를 생성 시 해당 테이블의 의도를 정확하게 파악한 후에 상황에 맞게 적절한 칼럼으로 **Clustered Index와 Non Clustered Index**를 구성해야 한다.
> 

**클러스터드 인덱스**

![출처: [https://gwang920.github.io/database/clusterednonclustered/](https://gwang920.github.io/database/clusterednonclustered/)](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2021.png)

출처: [https://gwang920.github.io/database/clusterednonclustered/](https://gwang920.github.io/database/clusterednonclustered/)

- **정의**
    - 행 데이터를 **물리적으로 정렬**하여 구성된 인덱스이다. 데이터를 정렬한 후 루트 페이지와 리프 페이지로 구성된 트리 구조로 저장된다.
- **특징**
    - 테이블당 단 하나의 클러스터 인덱스만 존재할 수 있다.
    - 기본 키(Primary Key)가 자동으로 클러스터 인덱스로 설정되며, 원하는 컬럼으로 변경 가능하다.
    - 데이터 입력, 수정, 삭제 시 **항상 정렬 상태를 유지**해야 한다.
- **데이터 검색 순서**
    - 루트 페이지 → 리프 페이지(데이터 페이지).
- **생성 시기**
    - 테이블 데이터가 자주 업데이트되지 않는 경우.
    - 범위 쿼리(MAX, MIN, COUNT 등) 또는 Group By 조회를 자주 사용하는 경우.
    - 데이터를 항상 정렬된 방식으로 반환해야 하는 경우.
    - 읽기 작업이 많을 때 적합하다.
- **장점**
    - **검색 속도가 빠르다**: 데이터가 정렬된 상태로 저장되기 때문에 효율적이다.
- **단점**
    - **페이지 분할 발생**: 새로운 데이터가 추가될 때 기존 데이터의 절반이 새로운 페이지로 이동되어 성능이 저하된다.

**비클러스터드 인덱스**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2022.png)

- **정의**
    - 데이터 페이지는 정렬되지 않고, **인덱스 페이지**만 별도로 생성하여 정렬된 상태로 유지하는 인덱스이다.
- **특징**
    - 데이터 페이지를 건드리지 않고 별도의 인덱스 페이지를 생성.
    - **리프 페이지**에는 키 값과 데이터 위치를 나타내는 포인터(RID)가 포함된다.
    - 테이블당 약 240개의 넌클러스터 인덱스를 생성 가능.
- **데이터 검색 순서**
    - 루트 페이지 → 리프 페이지 → 데이터 페이지(Heap page).
- **생성 시기**
    - `WHERE` 절, `JOIN` 절 등 조건문을 자주 사용하는 경우.
    - 데이터가 자주 업데이트되는 경우.
    - 특정 컬럼이 자주 쿼리에서 사용되는 경우.
- 장점:
    - **데이터 수정, 삭제가 빠르다.**
- **단점**
    - **추가 저장 공간 필요**: 인덱스 페이지를 따로 저장해야 한다.
    - **접근 속도 저하**: 클러스터 인덱스보다 검색 단계가 많아 느리다.
    - **인덱스 유지 비용 증가**: 데이터 변경 시 추가 작업이 필요하다.
    - **클러스터 인덱스 변경 시 영향 발생**: 데이터 정렬 변경에 따라 업데이트가 발생한다.

### B-Tree, Hash 인덱스

**B-Tree 인덱스**

![**B Tree -- Balanced Tree -- 균형잡힌 Tree**](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2023.png)

**B Tree -- Balanced Tree -- 균형잡힌 Tree**

- **정의**:
    - 데이터를 **균형 이진 트리 구조**로 저장하여 검색 속도를 최적화하는 인덱스이다.
- **특징**:
    - 데이터가 **트리 구조**로 저장되며, 모든 노드가 균형을 유지한다.
    - 데이터의 삽입, 삭제 시에도 트리 구조가 유지된다.
    - **범위 검색** 및 **정렬 작업**에 적합하다.
    - 클러스터드 및 넌클러스터드 인덱스 모두에서 활용된다.
- **장점**:
    1. 범위 검색과 순차 접근이 빠르다.
    2. 데이터가 트리 구조로 정렬되어 있어 정렬 작업이 필요 없다.
    3. 데이터 삽입 및 삭제 시에도 효율적이다.
- **단점**:
    1. **정확한 값 검색**에서는 Hash 인덱스보다 느릴 수 있다.
    2. 데이터가 많아질수록 트리의 높이가 증가하여 탐색 시간이 늘어날 수 있다.
    3. 구현이 상대적으로 복잡하다.

**Hash 인덱스**

![해시 인덱스는 검색하고자하는 값을 해시함수에 입력한 후 그 결과와 Bucket의 내용과 비교하여 해당 데이터 레코드의 위치를 찾을 수 있는 인덱스 기법](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2024.png)

해시 인덱스는 검색하고자하는 값을 해시함수에 입력한 후 그 결과와 Bucket의 내용과 비교하여 해당 데이터 레코드의 위치를 찾을 수 있는 인덱스 기법

- **정의**:
    - 해시 함수를 사용해 데이터를 특정 값에 매핑하여 저장하는 방식의 인덱스이다.
- **특징**:
    - **정확한 값 검색**에 최적화되어 있다.
    - 데이터를 해시 함수로 매핑하여 저장하므로, **범위 검색**이나 **정렬 작업**에는 적합하지 않다.
    - 데이터 삽입, 삭제 시에도 해시 매핑을 통해 빠르게 처리된다.
- **장점**:
    1. **정확한 값 검색**에서 빠른 검색 속도를 제공한다.
    2. 데이터 크기와 상관없이 일정한 검색 속도를 유지한다.
    3. 구현이 상대적으로 간단하다.
- **단점**:
    1. **범위 검색이나 정렬**에는 적합하지 않다.
    2. 해시 충돌이 발생할 경우 성능이 저하될 수 있다.
    3. 데이터 재정렬이 필요한 작업에서는 비효율적이다.

# 데이터 무결성과 보안

## 무결성 제약 조건

- **정의:**
    - 무결성 제약 조건은 **권한을 가진 사용자**에 의한 데이터베이스 갱신이 **일관성을 깨지 않도록 보장**하는 수단이다.
- 특징:
    - 스키마의 한 부분에 정의된다.
    - 데이터베이스의 상태에 대한 제한을 한다.
    - 릴레이션 내 무결성 제약 조건: 오직 한 릴레이션만 포함
    - 릴레이션 사이의 무결성 제약조건: 여러 릴레이션을 포함.
- 장점:
    - **자동 일관성 검사**: 스키마 정의 시 일관성 조건을 한 번만 명시하면, 데이터베이스 갱신 시 DBMS가 자동으로 일관성 조건을 검사한다.
    - **개발 효율성**: 응용 프로그램에서 별도의 일관성 검사가 필요하지 않아 개발이 간단해진다.

### 기본 키, 외래 키, 고유성, 도메인

**기본 키**

- **정의**:
    - 투플을 고유하게 식별하며, 데이터에 빠르게 접근할 수 있도록 설계된 키이다.
- **특징**:
    - 기본 키를 구성하는 애트리뷰트는 **NULL 값을 가질 수 없다**. (엔티티 무결성 조건)
- **역할**:
    - 데이터베이스에서 각 투플(행)을 **유일하게 식별**한다.

**외래 키**

- **정의**:
    - 두 릴레이션의 연관된 투플 간의 **일관성**을 유지하는 데 사용되는 키이다.
- **특징**:
    - 외래 키는 다른 릴레이션의 기본 키를 참조한다.
    - 릴레이션 간의 관계를 표현하는 데 중요하다.
- **역할**:
    - 릴레이션 간의 데이터 **참조 무결성**을 유지한다.

**고유성**

- **정의**:
    - 특정 속성에 저장된 값이 **중복되지 않도록** 보장하는 조건이다.
- **특징**:
    - 기본 키는 고유성을 포함하며, 고유 키(Unique Key)는 NULL 값을 가질 수 있다.
- **역할**:
    - 데이터 중복을 방지하고 무결성을 유지한다.

**도메인**

- **정의**:
    - 속성의 데이터 형식을 통해 값의 유형과 범위를 제한하는 조건이다.
- **특징**:
    - 속성의 **디폴트 값**을 지정할 수 있다.
    - 입력 값이 지정된 데이터 형식과 범위를 벗어나지 않도록 제한한다.
- **역할**:
    - 데이터 **유효성 검사**를 통해 입력 오류를 방지한다.

---

## 보안과 권한 관리

### **사용자 인증과 역할**

- **사용자 인증**:
    - **정의:**
        - 데이터베이스 접근 시 사용자 계정과 암호를 통해 인증을 수행하여 인증된 사용자만 데이터베이스에 접근 가능하게 하는 것
    - **예시**:
        
        ```sql
        GRANT CREATE SESSION TO 사용자;
        ```
        
- **역할(Role) 관리**:
    - **정의:**
        - 여러 권한을 하나의 역할로 묶어 관리하며, 역할을 사용자나 그룹에 부여하고, 역할 변경 시 모든 사용자에게 즉시 적용하는 것
    - **미리 정의된 역할**:
        - **CONNECT**: 데이터베이스 로그인 권한.
        - **RESOURCE**: 테이블, 인덱스 생성 권한.
    - **예시**:
        
        ```sql
        CREATE ROLE programmer;
        GRANT CREATE TABLE TO programmer;
        GRANT programmer TO CHOI;
        
        ```
        

### **데이터 암호화와 전송 보안**

- **데이터 암호화**:
    - **정의:**
        - 데이터베이스에 저장된 데이터를 암호화하여 무단 접근으로부터 보호하는 것
            - **암호화 알고리즘**: AES, RSA 등.
    - 사례: 민감한 사용자 정보를 암호화 저장하여 데이터 유출 시에도 안전성 확보.
- **전송 보안**:
    - 네트워크 전송 중 데이터를 암호화해 중간 탈취 방지.
    - **SSL/TLS**를 활용해 데이터 전송 중 암호화와 인증 보장.
    - 데이터베이스 클라이언트와 서버 간의 안전한 통신 제공.

---

# 데이터베이스 성능 최적화

---

## 실행 계획(Execution Plan) 분석

- **정의:**
    - 데이터베이스가 쿼리를 실행하는 과정을 시각적으로 표현한 것.
- **활용**
    - **인덱스 사용 여부** 확인.
    - 비효율적인 풀 스캔(FULL SCAN) 탐지.
    - 쿼리 성능 병목 구간 식별.

---

## 쿼리 최적화

### 인덱스 활용

- **정의:**
    - 자주 조회되는 열에 인덱스를 추가하여 **데이터 검색 속도**를 향상.
- **주의사항**
    - 너무 많은 인덱스는 데이터 수정/삭제 성능 저하를 초래.

### 정규화와 비정규화의 균형

- **정규화:**
    - 데이터 중복 제거와 데이터 무결성을 위해 테이블을 분리.
    - 예: 3NF까지 진행.
- **비정규화:**
    - 성능 향상을 위해 데이터 중복을 허용하고 테이블을 결합.
    - 예: 조회 성능 향상을 위해 조인을 줄임.

---

## 파티셔닝

- **정의:**
    - 동일한 DB 서버 내에서 테이블 또는 인덱스 데이터를 파티션(Partition) 단위로 나누어 저장하는 것.
- 출현 배경:
    - 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모가 대용량화.
    - 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하.
- 특징:
    - **관리용이성(Manageability):** 큰 table들을 제거하여 관리를 쉽게 해준다.
    - **가용성(Availability):** 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
    - **성능(Performance):** 특정 DML과 Query의 성능을 향상시킨다. 주로 대용량 Data WRITE 환경에서 효율적이다.
- 장점:
    - 관리적 측면:
        - 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다.
        - partition별로 백업 및 복구가 가능하다.
        - partition 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상시킨다.
    - 성능적 측면
        - 데이터 전체 검색 시 **필요한 부분만 탐색해 성능이 증가**한다.
        - 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.
- 단점:
    - table간 **JOIN에 대한 비용이 증가**한다.
    - table과 index를 별도로 파티셔닝할 수 없다.
    - table과 index를 같이 파티셔닝해야 한다.

### 수평 파티셔닝과 수직 파티셔닝

**수평 파티셔닝**

![수평 파티셔닝: 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2025.png)

수평 파티셔닝: 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것

- **정의:**
    - 데이터를 **행 기준**으로 나누는 방식.
- **특징**
    - 퍼포먼스, 가용성을 위해 KEY 기반으로 여러 곳에 분산 저장한다.
    - 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미한다.
    - 보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 경우를 지칭한다.
- **장점:**
    - 데이터의 개수를 기준으로 나누어 파티셔닝한다.
    - 데이터의 개수가 작아지고 따라서 인덱스의 개수도 작아지게 된다. 자연스럽게 성능은 향상된다.
- **단점:**
    - 서버간의 연결과정이 많아진다.
    - 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가하게 된다.
    - 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다.
- **예시**:
    - 사용자 데이터를 지역별로 분리.

**수직 파티셔닝**

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2026.png)

- **정의:**
    - 데이터를 **열 기준**으로 나누는 방식.
- **특징**
    - 필요한 데이터만 읽어 성능 향상.
    - 이미 정규화된 데이터를 분리하는 과정이다.
- **장점:**
    - 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.
    - 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.
    - 같은 타입의 데이터가 저장되기 때문에 저장 시 데이터 압축률을 높일 수 있다.
- **단점:**
    - 데이터를 찾는 과정이 기존보다 복잡하므로 Latency가 증가한다.
- **예시:**
    - 자주 조회되는 열과 나머지 열을 분리.

---

## 샤딩과 데이터 분산

**샤딩**

![각 DB 서버에 데이터 분할해서 저장하고 있는 그림 (샤딩)](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.21.35.png)

각 DB 서버에 데이터 분할해서 저장하고 있는 그림 (샤딩)

- **정의:**
    - 각 DB 서버에서 데이터를 분할하여 저장하는 방식.
- **특징:**
    - 데이터를 분산시켜 여러 대의 서버를 사용하고 병렬로 처리.
- **장점:**
    - 확장성과 성능을 향상시킨다.
- **예시:**
    - 사용자 ID를 기준으로 데이터베이스 분리.

샤딩과 파티셔닝의 차이

- **`수평적 파티셔닝`**은 **동일한 DB 서버 내에서 테이블을 분할**하는 것이고
- **`샤딩`**은 **DB 서버를 분할**하는 것이다.

![샤딩과 파티셔닝의 차이](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2027.png)

샤딩과 파티셔닝의 차이

**데이터 분산**

- **정의:**
    - 데이터 저장소를 **여러 노드에 분산**하여 처리 속도를 향상.
- **예시:**
    - NoSQL 시스템에서 자주 사용 (MongoDB, Cassandra).

---

# 비관계형 데이터베이스 (NoSQL)

## NoSQL 개요와 특징

- **정의:**
    - 전통적인 관계형 데이터베이스(RDBMS)와 달리, **스키마 없는 데이터**와 다양한 데이터 모델을 지원하는 데이터베이스.
- **특징**
    - **스키마 유연성**: 데이터 구조를 사전에 정의할 필요 없음.
    - **수평적 확장성**: 대규모 데이터를 처리하기 위해 여러 서버로 데이터 분산 가능.
    - **고성능**: 대량의 읽기/쓰기 작업에서 빠른 처리 속도 제공.
    - **다양한 데이터 모델**: 키-값, 문서형, 열 기반, 그래프 등 다양한 형태 지원.

---

## NoSQL의 유형

### 키-값 저장소: Redis, DynamoDB

- **정의**:
    - 간단한 키와 값의 쌍으로 데이터를 저장.
- **특징**:
    - 빠른 읽기/쓰기 성능 제공, 데이터 구조가 단순함.
- **대표 사례**:
    - **Redis**: 메모리 기반 데이터베이스로, 낮은 지연과 높은 처리 속도 제공.
    - **DynamoDB**: AWS에서 제공하는 분산 키-값 데이터베이스.

### 문서형 데이터베이스: MongoDB, CouchDB

- **정의**:
    - 데이터를 JSON, BSON 같은 문서 형태로 저장.
- **특징**:
    - 데이터 구조가 유연하고, 계층적인 데이터를 처리하기 적합.
- **대표 사례**:
    - **MongoDB**: 가장 널리 사용되는 문서형 데이터베이스, 스키마리스 설계 지원.
    - **CouchDB**: HTTP 프로토콜과 JSON 기반으로 설계된 데이터베이스.

### 열 기반 데이터베이스: Cassandra, HBase

- **정의**:
    - 데이터를 행(Row) 대신 **열(Column)** 단위로 저장.
- **특징**:
    - 대량의 데이터 분석과 읽기 작업에 적합.
- **대표 사례**:
    - **Cassandra**: 고가용성과 분산 시스템에서 뛰어난 성능 제공.
    - **HBase**: Hadoop과 통합하여 빅데이터 분석에 사용.

### 그래프 데이터베이스: Neo4j

- **정의**:
    - 노드와 간선(Graph)을 이용해 데이터를 표현.
- **특징**:
    - 관계 기반의 데이터를 빠르게 탐색 가능.
- **대표 사례**:
    - **Neo4j**: 가장 널리 사용되는 그래프 데이터베이스로, 소셜 네트워크 분석 등에 활용

---

## CAP 이론과 BASE 모델

**CAP 이론**

- **정의**:
    - 분산 시스템에서 **일관성(Consistency)**, **가용성(Availability)**, **분할 허용성(Partition Tolerance)** 세 가지 특성을 동시에 만족시킬 수 없음을 설명하는 이론.
- **요소:**
    - **Consistency**: 모든 클라이언트가 같은 데이터를 볼 수 있음.
    - **Availability**: 모든 요청에 대해 항상 응답 가능.
    - **Partition Tolerance**: 네트워크 분할 발생 시에도 시스템이 동작 가능.
- 사례:
    - **CP (Consistency + Partition Tolerance)**
        - 일관성을 유지하면서 네트워크 분할을 허용한다.
        - 예시:
            - **HBase**: 네트워크 분할 시 일부 요청을 차단하여 일관성을 유지.
    - **CA (Consistency + Availability)**
        - 일관성과 가용성을 유지하지만 네트워크 분할을 허용하지 않는다.
        - 예시:
            - **RDBMS (단일 노드 설정)**: 네트워크 분할이 없는 환경에서 일관성과 가용성을 제공.
    - **AP (Availability + Partition Tolerance)**
        - 가용성을 유지하면서 네트워크 분할을 허용한다.
        - 예시:
            - **Cassandra**: 네트워크 분할 중에도 요청을 처리하고 최종적으로 일관성을 달성.
            - **DynamoDB**: 가용성과 네트워크 분할 허용을 중시하며, 최종적 일관성을 보장.

**BASE 모델**

- **정의**:
    - NoSQL에서 CAP 이론의 **가용성**과 **분할 허용성**을 중시하는 설계 모델.
- **요소:**
    - **Basically Available**: 일부 장애 발생 시에도 시스템 일부는 동작 가능.
    - **Soft State**: 데이터 상태는 일시적으로 변경될 수 있음.
    - **Eventual Consistency**: 데이터는 결국 일관성을 유지.
- **특징:**
    - CAP 이론의 틀 안에서 가용성과 네트워크 분할 허용을 선택하고, 시스템의 일관성은 잠시 맞지 않더라도 최종적 일관성은 보장해주는 전략을 설명한다.
- **사례:**
    - **Cassandra**
        - **Basically Available**: 데이터를 여러 데이터 센터에 분산하여 높은 가용성을 보장.
        - **Soft State**: 데이터는 일시적으로 일관성이 깨질 수 있음.
        - **Eventual Consistency**: 시간이 지나면 모든 노드가 일관된 상태를 유지.
    - **DynamoDB**
        - **Basically Available**: 고가용성을 제공하며 데이터를 여러 지역에 복제.
        - **Soft State**: 데이터 업데이트가 즉시 반영되지 않을 수 있음.
        - **Eventual Consistency**: 모든 복제본이 최종적으로 일관된 상태를 유지.

---

# 분산 데이터베이스

---

## 분산 데이터베이스의 개념

- **정의:**
    - 데이터가 **여러 노드에 분산**되어 저장되고 처리되는 데이터베이스.
- **특징**
    - 고가용성과 확장성을 제공.
    - 데이터 저장소 간의 일관성 관리가 중요.

---

## 데이터 복제

### 마스터-슬레이브 복제

![image.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2028.png)

- **정의**:
    - 하나의 **마스터 노드**에서 데이터 쓰기 작업을 처리하고, 여러 **슬레이브 노드**에서 읽기 작업을 분담하여 데이터베이스의 부하를 분산하는 복제 방식.
- **특징**:
    - 쓰기 작업은 마스터에서만 가능하다.
    - 읽기 작업의 부하 분산이 가능하다.
- **장점:**
    - 읽기 성능이 향상된다.
    - 데이터 백업이 용이하다.
    - 확장성을 제공한다.
- **단점:**
    - 쓰기 병목 현상이 발생할 수 있다.
    - 데이터 동기화가 지연될 수 있다.
    - 마스터 장애 시 서비스가 중단된다.

### 리더-팔로워 복제

![프로듀서는 리더에게 메시지를 전송하게 되고, 리더는 자신을 파라보는 팔로워에게 데이터를 복제한다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/image%2029.png)

프로듀서는 리더에게 메시지를 전송하게 되고, 리더는 자신을 파라보는 팔로워에게 데이터를 복제한다.

- **정의**:
    - 리더 노드에서 쓰기 작업을 수행하고, 팔로워 노드에서 데이터를 복제 후 읽기 작업 처리.
- **특징**:
    - 리더 장애 시 팔로워 중 하나가 리더로 승격.
- **장점:**
    - 가용성이 향상된다.
    - 읽기 성능이 향상된다.
    - 데이터 복제를 자동화하여 데이터 동기화가 용이해진다.
- **단점:**
    - 데이터 동기화가 지연될 수 있다.
    - 리더 노드가 쓰기 작업의 병목 지점이 될 수 있다.
    - 리더 장애 처리와 팔로워 승격 과정을 설정 및 관리해야 한다.

**비교**

| **구분** | **마스터-슬레이브 복제** | **리더-팔로워 복제** |
| --- | --- | --- |
| **쓰기 작업** | 마스터 노드에서만 가능 | 리더 노드에서만 가능 |
| **읽기 작업** | 슬레이브 노드가 처리 | 팔로워 노드가 처리 |
| **장애 처리** | 마스터 장애 시 쓰기 작업 중단 | 리더 장애 시 팔로워가 리더로 승격 |
| **동기화 지연** | 슬레이브 노드로 복제 과정에서 지연 가능 | 팔로워 노드로 복제 과정에서 지연 가능 |
| **사용 사례** | MySQL, PostgreSQL | Kafka, Cassandra |

---

## 분산 트랜잭션

### 2PC(2-Phase Commit)

![다음과 같은 두 단계로 나뉜다.](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.36.17.png)

다음과 같은 두 단계로 나뉜다.

- **정의**:
    - **분산 환경에서 데이터 일관성을 보장**하기 위해 트랜잭션을 두 단계로 나누어 처리하는 **분산 트랜잭션 프로토콜**이다.
- **특징:**
    - 참여자(Participant)와 조정자(Coordinator) 간의 통신을 통해 모든 노드가 트랜잭션을 성공적으로 완료하거나, 문제 발생 시 트랜잭션을 중단하여 **데이터의 일관성을 유지**한다.
- **단계**
    - **Prepare Phase (준비 단계)**
        - 조정자(Coordinator)는 모든 참여자에게 **트랜잭션 준비 여부**를 묻는 **prepare 요청**을 보낸다.
        - 각 참여자는 트랜잭션을 실행할 수 있는 상태라면 `YES`를 응답하고, 준비 상태로 전환한다.
        - 트랜잭션을 실행할 수 없는 경우 `NO`를 응답하여 트랜잭션이 중단된다
        - **결과**:
            - 모든 참여자가 `YES`를 응답하면 **Commit Phase**로 진행.
            - 하나라도 `NO`를 응답하면 트랜잭션을 **중단(abort)**.
    - **Commit Phase (커밋 단계)**
        - 모든 참여자가 `YES`를 응답한 경우, 조정자가 **commit 요청**을 보내 트랜잭션을 완료한다.
        - 참여자 중 하나라도 `NO`를 응답하거나 조정자가 중단을 요청하면 **rollback 요청**을 보내 트랜잭션을 중단한다.
- 장점:
    - 모든 노드가 커밋하거나 롤백하도록 보장하여 **분산 환경에서 데이터의 일관성**을 유지한다.
    - 여러 데이터베이스나 시스템 간의 트랜잭션을 효과적으로 관리할 수 있다.
- 단점:
    - 참여자가 prepare 요청을 받고 yes를 응답한 후 코디네이터가 다운된다면 참여자는 더 이상 혼자 abort를 수행할 수 없다.
        
        ![스크린샷 2025-01-10 오후 12.37.42.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.37.42.png)
        
    - 분산 환경에서 참여자와 조정자 간 통신이 안정적이어야 하며, 통신 지연이 발생하면 트랜잭션 성능이 저하된다.
    - 모든 참여자가 준비 상태로 대기하기 때문에 **리소스 잠금 시간이 길어질 수 있다.**
    - 노드 수가 많아질수록 통신 비용과 지연이 증가한다.
- **동작 예시:**
    - 조정자가 참여자 A, B, C에게 **Prepare 요청**을 보낸다.
    - 참여자 A, B, C는 모두 `YES`를 응답하고 준비 상태로 전환한다.
    - 조정자는 모든 참여자의 응답을 확인한 후 **Commit 요청**을 보낸다.
    - 참여자 A, B, C는 트랜잭션을 커밋하고 성공 여부를 조정자에게 알린다.
- **문제 상황 예시:**
    - 참여자 A, B, C가 `YES`를 응답한 후, 조정자가 장애가 발생하여 **Commit 요청**을 보내지 못한다.
    - 참여자는 준비 상태에서 대기하며, 트랜잭션을 중단할 수도, 완료할 수도 없는 상태가 된다.

---

## 분산 시스템의 데이터 일관성

- **정의**:
    - 분산된 노드 간의 데이터가 **동일한 상태**를 유지하는 것.
- **특징:**
    - 시스템의 데이터가 최신 상태로 유지되며, 모든 사용자에게 동일한 결과를 제공하도록 보장한다.
- **유형:**
    
    **강한 일관성(Strong Consistency)**
    
    - **정의**:
        - 데이터가 업데이트되면 **모든 노드가 즉시 최신 상태로 반영**되어 일관성을 유지하는 기법이다.
        - 사용자가 시스템의 어느 노드에 접근하든 항상 최신 데이터를 읽을 수 있다.
    - **특징**:
        1. 모든 쓰기 작업이 완료된 후에야 읽기 작업이 가능하다.
        2. 쓰기 작업 완료 시점에 모든 노드가 데이터 변경을 즉시 반영해야 한다.
        3. 시스템의 신뢰성과 일관성이 높지만, 네트워크 지연이나 장애 상황에서는 처리 속도가 느려질 수 있다.
    - **장점**:
        - 모든 클라이언트가 항상 동일한 최신 데이터를 보장받을 수 있다.
        - 금융, 재고 관리 등 **정확성이 중요한 시스템**에 적합하다.
    - **단점**:
        - **응답 시간이 증가**: 모든 노드 간 동기화를 요구하기 때문에 지연 시간이 길어질 수 있다.
        - **확장성 문제**: 노드 수가 증가할수록 동기화 비용이 증가한다.
    - **사용 사례**:
        - **관계형 데이터베이스 (RDBMS)**
        - 금융 거래 시스템: 트랜잭션이 정확하게 반영되어야 하는 환경.
    
    **최종 일관성(Eventual Consistency)**
    
    - **정의**:
        - 데이터가 즉시 동기화되지 않고, **일정 시간이 지난 후에 모든 노드가 일관된 상태를 유지**하는 기법이다.
    - **특징**:
        1. 쓰기 작업이 완료되더라도 일부 노드에서는 업데이트된 데이터가 즉시 보이지 않을 수 있다.
        2. 데이터 변경 사항이 시간이 지나면서 점차 모든 노드에 전파된다.
        3. 가용성과 확장성을 중시하며, 일관성은 잠시 희생할 수 있다.
    - **장점**:
        - **고가용성 보장**: 네트워크 장애나 노드 실패 시에도 시스템이 지속적으로 동작 가능하다.
        - **확장성 높음**: 동기화에 대한 엄격한 제약이 없어 대규모 시스템에서도 성능이 유지된다.
    - **단점**:
        - **일시적 불일치**: 데이터가 최신 상태로 유지되지 않을 수 있으며, 사용자가 오래된 데이터를 읽을 가능성이 있다.
        - **데이터 정확성 감소**: 실시간 정합성이 필요한 환경에는 적합하지 않다.
    - **사용 사례**:
        - **NoSQL 데이터베이스 (Cassandra, DynamoDB)**
        - 소셜 네트워크, 채팅 애플리케이션: 실시간 정확성이 덜 중요한 환경.

---

# 데이터베이스 관리 및 백업

---

## 백업 전략

### 풀 백업, 증분 백업, 차등 백업

**풀 백업 (Full Backup)**

![스크린샷 2025-01-10 오후 12.48.41.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.48.41.png)

- **정의**: 데이터베이스 전체를 복사하여 백업하는 방식.
- **특징**:
    - 데이터 전체를 백업하므로 복구 시 가장 빠르고 간단하다.
    - 백업 크기가 크며, 실행 시간이 오래 걸린다.
- **장점**:
    - 복구가 빠르고 간단하다.
    - 모든 데이터를 안전하게 백업.
- **단점**:
    - 백업 크기가 크고 시간이 오래 걸린다.
    - 저장 공간 소모가 크다.
- **사용 시기**:
    - 주기적으로 중요한 데이터 전체를 보호해야 할 때.

**증분 백업 (Incremental Backup)**

![스크린샷 2025-01-10 오후 12.48.53.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.48.53.png)

- **정의**: 마지막 백업 이후 변경된 데이터만 백업.
- **특징**:
    - 백업 크기와 시간이 작다.
    - 복구 시 **풀 백업 + 여러 증분 백업** 필요하다.
- **장점**:
    - 백업 시간이 짧고 크기가 작다.
    - 저장 공간 효율적 사용.
- **단점**:
    - 복구 과정이 복잡하다.
    - 모든 증분 백업을 순차적으로 복구해야 한다
- **사용 시기**:
    - 빈번히 데이터가 변경되는 시스템에서 사용.

**차등 백업 (Differential Backup)**

![스크린샷 2025-01-10 오후 12.50.08.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.50.08.png)

- **정의**: 마지막 풀 백업 이후 변경된 데이터를 모두 백업.
- **특징**:
    - 백업 크기는 증분 백업보다 크지만, 복구는 더 간단하다.
    - **풀 백업 + 최신 차등 백업**으로 복구 가능하다.
- **장점**:
    - 복구가 비교적 간단하다.
    - 풀 백업과 최신 차등 백업만 필요.
- **단점**:
    - 증분 백업보다 크기와 시간이 더 많이 소요된다.
    - 백업 데이터가 점점 커질 수 있다.
- **사용 시기**:
    - 데이터 복구 시 증분 백업보다 간소화된 과정을 선호할 때.

---

## 장애 복구

### 로그 기반 복구와 체크포인트

**로그 기반 복구**

- **정의**:
    - **트랜잭션 로그**를 사용하여 데이터베이스의 상태를 복구하는 방법이다.
    - 트랜잭션의 작업 기록(로그)을 기반으로 장애 발생 이전의 상태를 재구성한다.
- **복구 과정**:
    1. **장애 발생 시 로그 확인**:
        - 트랜잭션 로그에서 작업 기록을 확인.
    2. **복구 작업 수행**:
        - **완료된 트랜잭션**: 로그를 확인하여 데이터베이스에 적용(커밋).
        - **미완료 트랜잭션**: 작업을 취소(롤백)하여 데이터베이스를 원래 상태로 복구.
- **장점**:
    - 데이터 손실을 최소화할 수 있다.
    - 세밀하고 정확한 복구가 가능하다.
- 단점:
    - 로그의 크기는 시간이 지남에 따라 계속 증가하므로 대용량 로그의 탐색 비용이 매우 커짐.
    - Redo를 해야 하는 트랜잭션 중 대부분은 이미 데이터베이스에 반영.
    - 반영된 트랜잭션의 재실행은 시스템 자원의 낭비.

**체크포인트**

- **정의**:
    - **데이터베이스 상태를 주기적으로 저장**하여, 장애 발생 시 복구 시간을 단축할 수 있도록 하는 기능이다.
    - 데이터베이스의 특정 시점 정보를 저장해 이후 복구 시 참조한다.
- **특징**:
    - **주기적 수행**: 일정 간격마다 시스템 상태를 저장.
    - 복구 시 **체크포인트 이후의 로그**만 확인하여 복구를 진행.
    - 복구 속도를 크게 향상시킨다.

---

## 데이터베이스 모니터링

- **정의**:
    - 데이터베이스 성능과 안정성을 유지하기 위해 상태를 지속적으로 관찰하고 문제를 해결하는 과정.
- **주요 모니터링 항목**:
    - **성능 지표**: CPU, 메모리, 디스크 사용량.
    - **쿼리 효율성**: 느린 쿼리 탐지 및 최적화.
    - **트랜잭션 상태**: 활성 트랜잭션, 잠금 현황.
    - **스토리지 상태**: 데이터베이스 용량 및 인덱스 상태.
    - **로그 관리**: 오류 로그 및 경고 로그 확인.
- **도구**:
    - MySQL Workbench, Oracle Enterprise Manager, PostgreSQL pgAdmin, Prometheus 등.
