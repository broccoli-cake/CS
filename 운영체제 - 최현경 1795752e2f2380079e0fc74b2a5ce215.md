# 운영체제 - 최현경

# 프로세스 관리 (Process Management)

## 프로세스와 스레드 (Processes and Threads)

### 프로세스 상태(Process States)

**프로세스**

- **정의**:
    - 운영체제에서 **실행 중인 프로그램**을 의미하는 독립적인 실행 단위
    - 실행에 필요한 자원(코드, 데이터, 스택, 힙)과 현재 상태 정보를 포함
    
    ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image.png)
    
    > 위 그림은 운영체제에서 각각의 프로세스가 독립적인 메모리 공간(Code, Data, Stack, Heap)을 가지며 서로 격리되어 실행됨을 보여줌
    > 
- **특징:**
    - 프로세스는 서로 독립적이며, 각 프로세스는 고유한 메모리 공간을 가짐
    - 운영체제는 프로세스의 자원 할당과 관리를 담당
    - 운영체제는 **PCB (Process Control Block)**를 통해 각 프로세스의 상태와 자원을 관리하며, 프로세스 전환 시 PCB를 참조하여 실행 상태를 저장하고 복구함
    - 프로세스는 생성, 준비, 실행, 대기, 종료의 **상태**를 가짐
        - **생성 (New)**
            - **정의**: 프로세스가 생성되었지만 아직 실행되지 않은 상태
            - **특징**:
                - 프로세스의 메모리 공간이 할당되고 초기화 작업이 이루어짐
                - 준비 상태(Ready)로 전이됨
        - **준비 (Ready)**
            - **정의**: 프로세스가 CPU를 할당받기 위해 대기 중인 상태
            - **특징**:
                - 실행 준비가 완료되었으나 CPU가 할당되지 않은 상태
                - CPU가 할당되면 실행 상태(Running)로 전이됨
        - **실행 (Running)**
            - **정의**: CPU가 프로세스에 할당되어 실제로 명령어가 실행되고 있는 상태
            - **특징**:
                - 프로세스가 CPU를 사용하여 작업을 수행함
                - 실행이 완료되면 종료 상태(Terminated)로 전이됨
                - 타이머에 의해 인터럽트를 받으면 준비 상태(Ready)로 전이됨
                - I/O 작업이 필요하면 대기 상태(Waiting)로 전이됨
        - **대기 (Waiting)**
            - **정의**: 프로세스가 I/O 작업이나 특정 이벤트를 기다리고 있는 상태
            - **특징**:
                - 파일 읽기, 네트워크 응답 등 외부 작업 대기 중인 상태
                - 작업이 완료되면 준비 상태(Ready)로 전이됨
        - **종료 (Terminated)**
            - **정의**: 프로세스의 실행이 완료되어 종료된 상태
            - **특징**:
                - 프로세스가 사용하던 자원이 해제됨
                - 운영체제에 의해 프로세스 정보가 정리됨
        
        **상태전이도:**
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%201.png)
        
        > 위 그림은 프로세스의 상태 전이를 나타내며, `New` 상태에서 시작해 `Terminated` 상태로 종료되는 과정을 설명함
        > 

**PCB (Process Control Block)**

- **정의**:
    - 프로세스 생성 시 운영체제가 생성하는 자료구조로, 프로세스의 상태와 정보를 관리함
- **특징**:
    - 각 프로세스의 실행과 관리를 위해 필수적인 정보를 포함함
    - 운영체제가 프로세스 전환(Context Switch)을 수행할 때 PCB를 참조하여 상태를 복구하거나 저장함
    - 프로세스별로 고유한 PCB가 생성되며, 프로세스의 전체 라이프사이클 동안 유지됨
- **포함 정보**:
    1. **Process 상태**: New, Ready, Running, Waiting, Terminated
    2. **프로세스 ID**: 각 프로세스를 고유하게 식별하는 ID
    3. **CPU 레지스터**: 프로세스 실행에 필요한 레지스터 정보
    4. **스케줄링 정보**: 우선순위, 스케줄링 큐 위치 등 스케줄링에 필요한 데이터
    5. **메모리 관련 정보**: 프로세스의 메모리 영역 정보 (코드, 데이터, 스택, 힙)
    6. **오픈된 파일 정보**: 프로세스가 접근 중인 파일 목록
    7. **통계 정보**: CPU 사용 시간, 메모리 사용량 등 성능 데이터
    8. **어카운팅 정보**: 프로세스별 CPU 및 메모리 자원 사용 통계

### 스레드(Thread)

- **정의**:
    - 프로세스 내에서 실행되는 작은 실행 단위
    - 동일한 프로세스 내에서 메모리와 자원을 공유하며 독립적으로 실행되는 제어의 흐름
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%202.png)
        
        > 위 그림은 하나의 프로세스 내에서 스레드들이 Code, Data, Heap 메모리를 공유하며, 각 스레드는 독립적인 Stack을 가지는 구조를 보여줌
        > 
- **특징**:
    - 같은 프로세스 내의 스레드는 메모리 공간(코드, 데이터 등)을 공유
    - 스레드는 프로세스보다 더 적은 자원으로 생성되고 관리됨
    - 스레드 간의 전환은 프로세스 간의 전환보다 빠름
    - 여러 스레드를 사용하여 동시에 작업을 수행할 수 있어 효율적인 프로그램 실행이 가능
    - 여러 스레드가 동시에 실행되며, 프로세스의 자원을 공유하면서 독립적으로 실행
- **장점**:
    - **응답 속도 향상**: 사용자와의 상호작용이 빠르게 이루어질 수 있음
    - **자원 공유로 메모리 소비 감소**: 별도의 메모리 공간 생성 없이 효율적으로 자원을 활용할 수 있음
    - **병렬 처리를 통한 성능 개선**: 다중 코어 환경에서 여러 작업을 병렬로 처리할 수 있음
    - **작업 간 데이터 공유가 용이**: 같은 프로세스 내 메모리를 공유하므로 데이터 교환이 빠르게 이루어질 수 있음
- **단점**:
    - **동기화 문제 발생 가능**: 여러 스레드가 동일한 메모리 공간을 사용하므로 데이터의 불일치 문제가 발생할 수 있음
    - **오류 전파 가능성**: 하나의 스레드에서 오류 발생 시 전체 프로세스에 영향을 줄 수 있음
- **활용**:
    - 두 개의 스레드를 생성하고 실행하며, 각 스레드가 고유한 메시지를 출력한 뒤 종료를 기다리는 프로그램
        
        ```c
        #include <stdio.h>
        #include <pthread.h>
        
        void* thread_function(void* arg) {
            printf("Thread %d is running.\n", *(int*)arg);
            return NULL;
        }
        
        int main() {
            pthread_t threads[2];
            int thread_args[2] = {1, 2};
        
            for (int i = 0; i < 2; i++) {
                pthread_create(&threads[i], NULL, thread_function, &thread_args[i]);
            }
        
            for (int i = 0; i < 2; i++) {
                pthread_join(threads[i], NULL);
            }
        
            return 0;
        }
        ```
        
    - 출력 결과**:**
        - 스레드 실행 순서는 운영 체제의 스케줄링에 따라 결정되며, `Thread 1 is running.`과 `Thread 2 is running.`의 순서는 실행마다 달라질 수 있음

## CPU 스케줄링 (CPU Scheduling)

- **정의**:
    - 제한된 CPU를 여러 프로세스가 동시에 사용하려 할 때, 어떤 프로세스를 실행(run 상태)할지 결정하는 운영체제의 메커니즘
- **특징**:
    - CPU를 최대한 효율적으로 사용하기 위해 프로세스의 우선순위, 실행 시간, 대기 시간 등을 고려하여 스케줄링
    - 레디 큐는 실행 대기 중인 프로세스를 관리하는 구조로, 스케줄링 알고리즘에 따라 프로세스 순서를 결정함
    - 스케줄링은 크게 선점형(Preemptive)과 비선점형(Non-preemptive)으로 구분됨
- **동작 방식**:
    - CPU 스케줄러는 레디 큐에 있는 프로세스 중 하나를 선택해 CPU를 할당
    - 선택된 프로세스는 실행 상태(run)로 전환되며, 나머지는 레디 큐에 대기

### 선점형 스케줄링 (Preemptive Scheduling)

- **정의**:
    - 실행 중인 프로세스가 CPU를 점유하고 있을 때, 운영 체제가 다른 프로세스에 CPU 자원을 할당하기 위해 현재 프로세스를 강제로 중단할 수 있는 방식이다.
- **특징**:
    - 운영 체제가 특정 조건(예: 높은 우선순위의 프로세스가 대기 중일 때)에서 현재 실행 중인 프로세스를 중단하고 다른 프로세스에 CPU를 할당
    - Context Switching(문맥 교환)이 필수적으로 발생
    - 실시간 응답 환경, 데드라인 응답 환경 등 우선순위가 높은 프로세스를 먼저 처리해야 하는 경우에 유용
- **동작 방식**:
    - 새로운 프로세스가 도착하면 실행 중인 프로세스와 우선순위를 비교
    - 높은 우선순위 프로세스가 있다면 현재 프로세스를 중단하고 대기 상태로 전환
    - 새로운 프로세스에 CPU를 할당
- **장점**:
    - 실시간 시스템에서 효과적
    - 높은 우선순위 작업의 데드라인 준수 가능
- **단점**:
    - 문맥 교환으로 인한 성능 저하 가능
    - 낮은 우선순위 작업이 기아 상태(Starvation)에 빠질 가능성
- **활용**:
    - 대표 알고리즘: Round Robin, STCF

**Round Robin (RR)**

- **정의**:
    - 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간 단위(Time Quantum/Slice)로 CPU를 할당하는 방식이다.
- **특징**:
    - 타임 퀀텀 단위로 프로세스를 번갈아가며 실행
    - 타임 퀀텀이 끝나면 프로세스는 대기열의 뒤로 이동하며 문맥 교환이 발생
- **동작 방식**:
    - 대기열에서 첫 번째 프로세스를 CPU에 할당
    - 타임 퀀텀 종료 시 프로세스는 대기열의 끝으로 이동
    - 모든 프로세스가 완료될 때까지 반복
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%203.png)
        
        > 위 그림은 타임 퀀텀 4인 Round Robin 스케줄링에서 P1, P2, P3 프로세스가 도착 순서대로 4단위 시간씩 CPU를 번갈아가며 할당받아 실행되는 것을 보여줌
        > 
- **장점**:
    - 응답 시간이 빠름
    - 공정한 CPU 자원 분배
- **단점**:
    - 타임 퀀텀 크기에 따라 성능이 달라짐
    - 문맥 교환에 따른 오버헤드 발생
- **활용**:
    - 사용자 응답 시간이 중요한 시스템

**Priority Scheduling**

- **정의**:
    - 프로세스를 우선순위에 따라서 순서대로 처리하는 알고리즘이다.
- **특징**:
    - 도착한 프로세스의 우선순위와 현재 실행 중인 프로세스의 우선순위를 비교하여 높은 우선순위 작업부터 처리
    - 우선순위가 같을 경우 FCFS(First Come First Serve)를 적용
- **동작 방식**:
    - 프로세스 도착 시 우선순위를 확인
    - 높은 우선순위의 작업이 있으면 먼저 실행
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%204.png)
        
        > 위 그림은 Priority Scheduling에서 프로세스가 우선순위에 따라 P2, P5, P1, P3, P4 순서대로 CPU를 할당받아 실행되는 것을 보여줌
        > 
- **장점**:
    - 긴급한 작업의 빠른 처리 가능
- **단점**:
    - 낮은 우선순위 작업의 지연 또는 기아 상태 발생 가능
- **활용**:
    - 작업 중요도가 명확히 구분되는 시스템

**Multilevel Feedback Queue (MLFQ)**

- **정의**:
    - 프로세스를 목적에 맞게 여러 개의 큐로 나누고, 각 큐마다 다른 스케줄링 알고리즘을 적용하는 방식이다.
- **특징**:
    - CPU 사용량에 따라 우선순위를 조정
    - Starvation 문제를 해결하기 위해 Aging 기법을 적용
    - 높은 우선순위 큐에는 Round Robin을, 낮은 우선순위 큐에는 FCFS를 적용
- **동작 방식**:
    - 새로운 작업은 가장 높은 우선순위의 큐에 배치
    - 타임 퀀텀 소진 시 낮은 우선순위로 이동
    - 주기적으로 우선순위를 높이는 Periodic Boosting을 사용
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%205.png)
        
        > 위 그림은 Multi-Level Queue 스케줄링에서 프로세스를 우선순위에 따라 real-time processes, system processes, interactive processes, batch processes 순서로 분류하여 높은 우선순위부터 실행하는 구조를 보여줌
        > 
- **장점**:
    - 실시간성과 반환 시간의 균형
    - 다양한 작업 환경에 적합
- **단점**:
    - 스케줄러 설계가 복잡
    - 우선순위 속임수 가능
- **활용**:
    - 실시간 작업과 배치 작업이 혼재된 환경

### 비선점형 스케줄링 (Non-preemptive Scheduling)

- **정의**:
    - 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 방식이다.
- **특징**:
    - 문맥 교환 오버헤드가 적음
    - 현재 작업이 끝날 때까지 다른 작업은 대기
- **동작 방식**:
    - 프로세스 도착 순서에 따라 대기열에 추가
    - 실행 중인 프로세스가 종료되면 대기열에서 첫 번째 프로세스를 CPU에 할당
- **장점**:
    - 구현이 간단
    - 문맥 교환 오버헤드가 없음
- **단점**:
    - 높은 우선순위 작업의 처리 지연 가능
    - Convoy Effect 발생 가능
- **활용**:
    - 배치 시스템, 간단한 응답 환경
    - 대표 알고리즘: FCFS, SJF

**FCFS (First Come First Serve)**

- **정의**:
    - 먼저 도착한 프로세스부터 처리하는 방식이다.
- **특징**:
    - 공평한 처리 순서 보장
    - Convoy Effect 발생 가능
- **동작 방식**:
    - 도착한 순서대로 대기열에 추가
    - 대기열의 첫 번째 프로세스를 실행
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%206.png)
        
        > 위 그림은 Multi-Level Queue 스케줄링에서 프로세스를 우선순위에 따라 real-time processes, system processes, interactive processes, batch processes 순서로 분류하여 높은 우선순위부터 실행하는 구조를 보여줌
        > 
- **장점**:
    - 구현이 간단
    - 공평한 자원 분배
- **단점**:
    - 긴 작업이 앞에 있을 경우 뒤의 작업들이 지연됨 (Convoy Effect)
- **활용**:
    - 처리 시간이 비슷한 작업들

**SJF (Shortest Job First)**

- **정의**:
    - 대기 중인 작업 중 실행 시간이 가장 짧은 작업부터 처리하는 방식이다.
- **특징**:
    - 짧은 작업 우선 처리
    - CPU Burst Time을 미리 알아야 함
- **동작 방식**:
    - 대기 중인 작업의 CPU Burst Time을 비교
    - 가장 짧은 작업을 CPU에 할당
        
        ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%207.png)
        
        > 위 그림은 SJF(Shortest Job First) 스케줄링에서 Burst Time이 낮은 순서대로 P4, P1, P3, P2 프로세스가 CPU를 할당받아 실행되는 것을 보여줌
        > 
- **장점**:
    - 평균 대기 시간 감소
    - 반환 시간 최적화 가능
- **단점**:
    - 작업 시간 예측이 어려움
    - 기아 상태 발생 가능
- **활용**:
    - 짧은 작업이 많은 환경

### 스케줄링 성능 평가

- **정의**:
    - CPU 스케줄링의 효과를 측정하고 평가하기 위해 사용되는 성능 지표
- **특징**:
    - CPU 스케줄링은 성능 향상과 자원 활용 극대화를 목표로 하며, 이를 평가하기 위해 다양한 매트릭(Metrics)을 사용
    - 사용되는 성능 지표는 상황과 시스템의 목표에 따라 중요도가 달라질 수 있음
    - 주요 성능 지표로 반환시간, 응답시간, 형평성, 처리율, 마감시간 등이 사용됨
    - 각 지표는 특정 상황에 맞는 스케줄링 정책을 선택하는 데 도움을 줌
- **동작 방식**:
    - 반환시간, 응답시간, 처리율 등 매트릭을 통해 스케줄링 정책의 성능을 측정
    - 시스템의 특성과 목표에 따라 가장 중요한 매트릭을 우선적으로 고려
    - 스케줄링 알고리즘이 적절히 동작하도록 평가 결과를 피드백
- **주요 매트릭**:
    1. **반환시간 (Turnaround time)**:
        - **정의**: 작업이 제출된 시간과 완료된 시간 간의 차이를 의미
        - **식**: $T_{turnaround}=T_{completion}−T_{arrival}$
        - **장점**: 작업이 얼마나 빠르게 완료되었는지를 측정 가능
        - **단점**: 특정 작업이 길어지면 반환시간이 과도하게 늘어날 수 있음
    2. **응답시간 (Response time)**:
        - **정의**: 작업이 제출된 후 실행이 시작될 때까지의 시간을 의미
        - **식**:$T_{response}=T_{start}−T_{arrival}$
        - **장점**: 시스템 반응 속도를 측정 가능
        - **단점**: 응답시간을 줄이기 위해 반환시간이나 처리율을 희생할 수 있음
    3. **형평성 (Fairness)**:
        - **정의**: 작업 간의 완료 시간 차이를 줄여 공평하게 자원을 할당하는 정도를 평가
        - **식**: $F =|T_{\text{completion}}^{P1} - T_{\text{completion}}^{P2}|$
        - **장점**: 모든 작업에 공정한 자원 할당을 보장
        - **단점**: 형평성을 지나치게 중시하면 중요한 작업의 우선순위가 낮아질 수 있음
    4. **처리율 (Throughput)**:
        - **정의**: 단위 시간 동안 완료된 작업의 수를 의미
        - **식**: $T_{throughput} = \frac{\text{Number of jobs completed}}{\text{Total time}}$
        - **장점**: 시스템의 작업 처리 효율성을 측정 가능
        - **단점**: 처리율을 높이기 위해 짧은 작업 위주로 처리하면 긴 작업이 지연될 가능성이 있음
    5. **마감시간 (Deadline)**:
        - **정의**: 작업이 지정된 마감시간 내에 완료되었는지를 평가
        - **식**: $D = T_{completion} \leq T_{deadline}$
        - **장점**: 실시간 시스템에서 중요한 작업의 적시 완료 보장
        - **단점**: 마감시간을 충족하기 위해 다른 작업의 성능을 희생할 수 있음
- **장점**:
    - 다양한 지표를 통해 스케줄링 정책의 효과를 다각도로 평가 가능
    - 시스템의 목표와 요구사항에 맞는 스케줄링 알고리즘 선택에 도움
- **단점**:
    - 모든 매트릭을 동시에 만족시키기 어려움 (예: 응답시간과 형평성 간의 상충)
    - 특정 지표에 집중할 경우 다른 성능 요소가 저하될 가능성
- **활용**:
    - 실시간 시스템에서는 마감시간을 우선 고려
    - 사용자와의 상호작용이 많은 환경에서는 응답시간을 중시
    - 배치 작업 환경에서는 처리율을 최대화

## 동기화 (Synchronization)

- **정의**:
    - 여러 프로세스나 스레드가 동시에 실행될 때, 공유 자원의 일관성을 유지하고 정확한 실행 순서를 보장하기 위한 메커니즘
- **특징**:
    - 프로세스 간의 데이터 충돌 및 무결성 문제를 해결
    - 상호 배제(Mutual Exclusion)를 통해 한 번에 하나의 프로세스만 공유 자원에 접근 가능
    - 임계 구역(Critical Section) 문제를 해결하며 진행 조건(Progress)과 한정 대기(Bounded Waiting)를 보장
    - 동기화를 위해 세마포어, 모니터, 뮤텍스, 조건 변수와 같은 기법을 사용
- **동작 방식**:
    - 공유 자원에 접근하기 전, 특정 조건을 만족한 프로세스만 접근 허용
    - 접근 종료 후, 대기 중인 다른 프로세스가 자원을 사용할 수 있도록 관리
    - 필요한 경우 대기와 신호를 활용해 동기화 상태를 유지

### 임계 구역 문제 (Critical Section Problem)

- **정의**:
    - 여러 프로세스가 동시에 접근하면 문제가 발생할 수 있는 공유 자원의 코드 영역
- **특징**:
    - **상호 배제(Mutual Exclusion)**: 하나의 프로세스만 임계 구역에 접근 가능
    - **진행 조건(Progress)**: 임계 구역에 들어갈 프로세스를 공정하게 결정
    - **한정 대기(Bounded Waiting)**: 특정 프로세스가 무한 대기하지 않도록 보장
- **동작 방식**:
    - 프로세스는 임계 구역에 진입하기 전에 허가를 요청
    - 한 번에 하나의 프로세스만 임계 구역에 진입 가능
    - 작업 종료 후, 다른 프로세스가 임계 구역에 접근하도록 허용

### 세마포어(Semaphore)와 모니터(Monitor)

**세마포어**

- **정의**:
    - 프로세스 간 동기화 및 상호 배제를 위해 사용되는 정수형 변수
- **특징**:
    - **값 관리**: 세마포어 값(S)을 통해 공유 자원 접근 가능 여부를 관리
    - **종류**:
        - **카운팅 세마포어**: 0 이상의 값을 가지며, 자원 개수를 관리
        - **이진 세마포어**: 0과 1만 가지며, 뮤텍스와 유사하게 동작
    - **연산**:
        - **Wait(P 연산)**: 세마포어 값을 감소시키며, 값이 0보다 작아지면 대기 상태로 전환
        - **Signal(V 연산)**: 세마포어 값을 증가시키며, 대기 중인 프로세스를 깨움
- **동작 방식**:
    - Wait(P 연산): 세마포어 값을 감소시키며, 값이 0보다 작아지면 프로세스를 대기 상태로 전환
    - Signal(V 연산): 세마포어 값을 증가시키며, 대기 중인 프로세스를 깨워 실행
    - 여러 프로세스가 동일 자원을 요청하면 세마포어 값이 음수가 되어 대기 큐에 추가됨
- **장점**:
    - 간단하면서도 효율적인 자원 관리 가능
    - 여러 프로세스 간 동기화 및 상호 배제를 효과적으로 지원
    - 카운팅 세마포어를 통해 여러 자원 동시 관리 가능
    - 분산 시스템에서도 활용 가능
- **단점**:
    - **Busy Waiting** 문제: Wait 연산 중 자원이 비활성화되었을 때 CPU 자원을 낭비하며 대기
    - 프로그래머가 Wait와 Signal 호출 순서를 잘못 설정하면 데드락(Deadlock)이나 기아 상태(Starvation)가 발생할 수 있음
    - 다중 세마포어 사용 시 복잡도가 증가하고 관리 어려움
- **활용**:
    - 생산자-소비자 문제, 독자-작가 문제, 제한된 자원 접근 관리
    - 제한된 연결 개수(예: 데이터베이스 커넥션 풀)와 같은 자원 제어에 유용
        
        ```c
        #include <semaphore.h>
        #include <pthread.h>
        #include <stdio.h>
        
        sem_t semaphore; // 세마포어 변수 선언
        
        void* thread_function(void* arg) {
            sem_wait(&semaphore); // 세마포어 잠금 (임계 구역에 진입)
            printf("Thread %ld is in the critical section\n", pthread_self()); // 현재 스레드가 임계 구역에 진입했음을 출력
            sem_post(&semaphore); // 세마포어 해제 (임계 구역에서 나옴)
            return NULL;
        }
        
        int main() {
            pthread_t threads[3]; // 스레드 배열 생성
            sem_init(&semaphore, 0, 1); // 세마포어 초기화 (이진 세마포어로 설정, 초기 값 1)
        
            for (int i = 0; i < 3; i++) {
                pthread_create(&threads[i], NULL, thread_function, NULL); // 스레드 생성
            }
        
            for (int i = 0; i < 3; i++) {
                pthread_join(threads[i], NULL); // 각 스레드가 종료될 때까지 대기
            }
        
            sem_destroy(&semaphore); // 세마포어 제거
            return 0;
        }
        
        ```
        

**모니터**

- **정의**:
    - 공유 자원을 관리하고 동기화를 지원하는 고수준의 동기화 도구
- **특징**:
    - **자원 은닉**: 공유 자원은 모니터 내부에서 숨겨지고, 접근 인터페이스(프로시저)만 제공
    - **상호 배제**: 한 번에 하나의 프로세스만 모니터 내부에서 작업 가능
    - **조건 관리**: 조건 변수와 Wait, Signal 연산을 통해 동기화
    - 동시성을 프로그래밍 언어 수준에서 지원하여 복잡도를 낮춤
    - 자바의 `synchronized` 키워드와 Python의 `threading.Condition` 등에서 사용 가능
- **동작 방식**:
    - 모니터는 요청을 순차적으로 처리하며, 공유 자원의 일관성을 보장
    - 조건이 만족되지 않을 경우 `wait`을 호출해 스레드를 대기 상태로 전환
    - 조건 만족 시 `signal`을 호출해 대기 중인 스레드를 활성화
    - 작업 완료 후 다른 프로세스가 자원을 사용할 수 있도록 관리
- **장점**:
    - **코드 간결성**: 고수준 동기화 지원으로 프로그래머의 구현 부담 감소
    - **안전성**: 공유 자원 접근을 제한하며, 상호 배제를 기본적으로 지원
    - 다중 조건 변수 지원으로 복잡한 동기화 문제 해결
- **단점**:
    - 운영체제나 프로그래밍 언어에 따라 구현 차이가 있음
    - 자원이 제한된 시스템에서는 비효율적일 수 있음
    - Wait-Signal 순서 오류 시 예상치 못한 결과 발생 가능
- **활용**:
    - 자바에서 스레드 동기화(`synchronized`)와 조건 관리에 사용
    - 생산자-소비자 패턴, 작업 대기열 관리, 실시간 데이터 처리
        
        ```java
        class MonitorExample {
          private int sharedResource = 0; // 공유 자원
        
          // synchronized를 사용해 임계 구역 설정
          public synchronized void increment() { 
            sharedResource++;
            System.out.println(Thread.currentThread().getName() + " incremented: " + sharedResource);
          }
        
          public synchronized void decrement() { 
            sharedResource--;
            System.out.println(Thread.currentThread().getName() + " decremented: " + sharedResource);
          }
        }
        
        public class MonitorDemo {
          public static void main(String[] args) {
            MonitorExample monitor = new MonitorExample(); // 모니터 객체 생성
        
            // 스레드들이 공유 자원에 접근
            Thread t1 = new Thread(() -> {
              for (int i = 0; i < 5; i++) monitor.increment(); // 자원 증가
            });
        
            Thread t2 = new Thread(() -> {
              for (int i = 0; i < 5; i++) monitor.decrement(); // 자원 감소
            });
        
            t1.start(); // 스레드 시작
            t2.start(); // 스레드 시작
          }
        }
        ```
        

### 뮤텍스(Mutex)와 조건 변수(Condition Variables)

**뮤텍스**

- **정의**:
    - 임계 구역(Critical Section)에 한 번에 하나의 스레드만 접근하도록 상호 배제를 보장하는 동기화 기법
- **특징**:
    - **상호 배제**: 자원을 사용하려는 스레드는 뮤텍스를 잠금(Lock)으로써 다른 스레드의 접근을 방지
    - **소유권**: 뮤텍스는 특정 스레드가 소유하며, 소유한 스레드만 잠금 해제 가능
    - **데드락 위험**: 잘못된 사용(예: 잠금 후 해제를 하지 않거나 두 개의 뮤텍스가 순환적으로 대기하는 경우)에 따라 데드락(Deadlock) 상태에 빠질 수 있음
- **동작 방식**:
    - **Lock**: 자원을 사용하려는 스레드가 뮤텍스를 잠금
    - **Critical Section**: 잠금 상태에서 공유 자원에 접근
    - **Unlock**: 자원 사용이 끝난 스레드가 뮤텍스를 해제하여 다른 스레드가 접근 가능
- **장점**:
    - 단일 임계 구역 보호에 적합하며 구현이 간단
    - 자원 경합을 효과적으로 방지
- **단점**:
    - 다중 자원 간의 데드락 위험
    - 스핀락(Spinlock)과 달리 Context Switching으로 인해 성능 저하 가능
- **활용**:
    - 다중 스레드 환경에서 자원에 대한 동시 접근을 제어할 필요가 있는 모든 경우
    - 주로 공유 변수, 파일, 네트워크 리소스 보호에 사용됨
        
        ```c
        #include <pthread.h>
        #include <stdio.h>
        
        pthread_mutex_t mutex; // 뮤텍스 선언 (스레드 동기화에 사용)
        
        void* thread_function(void* arg) {
            pthread_mutex_lock(&mutex); // 뮤텍스 잠금 (임계 구역에 진입)
            printf("Thread %ld is in the critical section\n", pthread_self()); // 현재 스레드가 임계 구역에 있음을 출력
            pthread_mutex_unlock(&mutex); // 뮤텍스 해제 (임계 구역에서 나옴)
            return NULL;
        }
        
        int main() {
            pthread_t threads[2]; // 두 개의 스레드 선언
            pthread_mutex_init(&mutex, NULL); // 뮤텍스 초기화
        
            for (int i = 0; i < 2; i++) {
                pthread_create(&threads[i], NULL, thread_function, NULL); // 스레드 생성
            }
        
            for (int i = 0; i < 2; i++) {
                pthread_join(threads[i], NULL); // 각 스레드가 종료될 때까지 대기
            }
        
            pthread_mutex_destroy(&mutex); // 뮤텍스 자원 해제
            return 0;
        }
        
        ```
        
- **정의**:
    - 임계 구역(Critical Section)에 한 번에 하나의 스레드만 접근하도록 상호 배제를 보장하는 동기화 기법
- **특징**:
    - **상호 배제**: 자원을 사용하려는 스레드는 뮤텍스를 잠금(Lock)으로써 다른 스레드의 접근을 방지
    - **소유권**: 뮤텍스는 특정 스레드가 소유하며, 소유한 스레드만 잠금 해제 가능
    - **데드락 위험**: 잘못된 사용(예: 잠금 후 해제를 하지 않거나 두 개의 뮤텍스가 순환적으로 대기하는 경우)에 따라 데드락(Deadlock) 상태에 빠질 수 있음
- **동작 방식**:
    - **Lock**: 자원을 사용하려는 스레드가 뮤텍스를 잠금
    - **Critical Section**: 잠금 상태에서 공유 자원에 접근
    - **Unlock**: 자원 사용이 끝난 스레드가 뮤텍스를 해제하여 다른 스레드가 접근 가능
- **장점**:
    - 단일 임계 구역 보호에 적합하며 구현이 간단
    - 자원 경합을 효과적으로 방지
- **단점**:
    - 다중 자원 간의 데드락 위험
    - 스핀락(Spinlock)과 달리 Context Switching으로 인해 성능 저하 가능
- **활용**:
    - 다중 스레드 환경에서 자원에 대한 동시 접근을 제어할 필요가 있는 모든 경우
    - 주로 공유 변수, 파일, 네트워크 리소스 보호에 사용됨

**조건 변수**

- **정의**:
    - 특정 조건이 충족될 때까지 스레드를 대기 상태로 만들거나 조건 충족 시 대기 중인 스레드를 깨우는 동기화 기법
- **특징**:
    - **조건 기반 대기**: 조건이 충족되지 않을 경우 스레드는 `wait` 상태로 진입하여 CPU를 차지하지 않음
    - **신호 전달**: `signal` 또는 `broadcast`를 통해 조건 충족 시 대기 중인 스레드를 깨움
    - **뮤텍스와 결합**: 조건 변수는 뮤텍스와 함께 사용하여 임계 구역의 조건을 관리
- **동작 방식**:
    - **조건 대기**: 조건이 충족되지 않으면 스레드는 `pthread_cond_wait`로 대기 상태 전환
    - **조건 신호**: 조건이 충족되면 `pthread_cond_signal`이나 `pthread_cond_broadcast`로 스레드를 깨움
    - **작업 재개**: 깨워진 스레드는 뮤텍스를 다시 얻은 후 임계 구역 작업을 수행
- **장점**:
    - CPU를 효율적으로 사용하며 불필요한 Busy Waiting을 방지
    - 여러 스레드 간 복잡한 상호작용 관리 가능
- **단점**:
    - 뮤텍스와 함께 사용해야 하며 구현 복잡성 증가
    - 대기 중인 스레드가 여러 개일 경우 우선순위를 고려하지 않음
- **활용**:
    - 데이터 준비 상태에 따라 스레드의 작업 순서를 조정해야 하는 경우
    - 생산자-소비자(Producer-Consumer) 문제 등에서 사용
        
        ```c
        #include <pthread.h>
        #include <stdio.h>
        
        pthread_mutex_t mutex;
        pthread_cond_t cond; // 조건 변수 선언
        int ready = 0;
        
        void* producer(void* arg) {
            pthread_mutex_lock(&mutex);
            ready = 1; // 조건 변경
            printf("Producer: Condition is met, signaling...\n");
            pthread_cond_signal(&cond); // 조건 변수 신호 보내기
            pthread_mutex_unlock(&mutex);
            return NULL;
        }
        
        void* consumer(void* arg) {
            pthread_mutex_lock(&mutex);
            while (!ready) {
                printf("Consumer: Waiting for condition...\n");
                pthread_cond_wait(&cond, &mutex); // 조건 변수 대기
            }
            printf("Consumer: Condition met, proceeding...\n");
            pthread_mutex_unlock(&mutex);
            return NULL;
        }
        
        int main() {
            pthread_t t1, t2;
            pthread_mutex_init(&mutex, NULL);
            pthread_cond_init(&cond, NULL);
        
            pthread_create(&t1, NULL, producer, NULL);
            pthread_create(&t2, NULL, consumer, NULL);
        
            pthread_join(t1, NULL);
            pthread_join(t2, NULL);
        
            pthread_mutex_destroy(&mutex);
            pthread_cond_destroy(&cond);
        
            return 0;
        }
        
        ```
        

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%208.png)

> 이 다이어그램은 조건 변수를 사용해 **스레드의 작업 수행을 조율하는 방식**을 시각적으로 표현한 것으로, 뮤텍스를 통해 임계 구역을 보호하며, 조건이 충족되지 않을 경우 스레드를 대기 상태로 보내고, 조건 충족 시 대기 중인 스레드가 작업을 이어갈 수 있음을 보여줌.
> 

## 교착상태 (Deadlock)

- **정의**:
    - 둘 이상의 프로세스가 서로 자원을 점유한 상태에서, 필요한 자원을 얻기 위해 서로 대기하다가 영원히 진행될 수 없는 상태.
- **특징**:
    - 일어나지 않을 사건을 기다리며 발생한다.
    - 데드락 상황을 확인하기 위해, 자원 할당 그래프를 이용하여 확인할 수 있다.
    - 자원 할당 그래프가 원의 형태를 띄고 있으면 데드락이 발생한다.
    - 4가지의 데드락 조건을 모두 만족한다면 데드락이 발생할 수 있다.

### 교착상태의 조건 (Conditions for Deadlock)

- **상호 배제 (Mutual Exclusion)**:
    - **정의**:
        - 자원은 한 번에 하나의 프로세스만 점유 가능하며, 다른 프로세스는 자원을 사용할 수 없는 상태
    - **특징**:
        - 배타적으로 사용되는 자원에서만 발생 (예: 프린터, 파일 쓰기 등)
        - 자원을 공유하지 않고 독점적으로 사용하는 경우 상호 배제를 보장
        - 공유 자원을 보호하는 뮤텍스나 세마포어로 인해 발생 가능
    - **동작 방식**:
        - 자원이 이미 한 프로세스에 의해 점유되었을 경우, 다른 프로세스는 해당 자원이 해제될 때까지 대기
            
            ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%209.png)
            
        
        > 위 그림은 프로세스 P1이 공유 메모리(임계 영역)에 먼저 진입하여 작업 중일 때, P2가 동일 영역에 접근하려다 실패하는 상황을 보여줌
        > 
- **점유와 대기 (Hold and Wait)**
    - **정의**:
        - 프로세스가 최소 하나의 자원을 점유한 상태에서 추가 자원을 요청하며 대기하는 상태
    - **특징**:
        - 이미 점유한 자원을 반납하지 않은 채 다른 자원을 요구함
        - 자원의 점유와 대기가 동시에 발생하여 교착상태 위험 증가
        - Deadlock Prevention 기법에서 점유와 대기 조건을 제거함으로써 해결 가능
    - **동작 방식**:
        - 프로세스가 첫 번째 자원을 점유한 뒤 추가 자원을 요청
        - 요청한 자원이 점유된 상태라면 해당 프로세스는 대기 상태에 들어감
- **비선점 (No Preemption)**:
    - **정의**:
        - 이미 할당된 자원을 강제로 회수할 수 없는 상태
    - **특징**:
        - 자원을 점유한 프로세스가 자발적으로 반환할 때까지 다른 프로세스는 대기
        - 선점이 가능한 자원에서는 발생하지 않음
        - 데이터 일관성을 보장하기 위해 비선점이 필요한 경우가 있음
    - **동작 방식**:
        - 프로세스가 자원을 점유하고 있을 때 강제로 자원을 회수하지 않고 작업 완료 후 반환
        - 점유된 자원이 반환될 때까지 대기 중인 프로세스는 진입 불가
- **순환 대기 (Circular Wait)**:
    
    ![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2010.png)
    
    > 교착상태의 조건 중 하나인 순환대기 상태
    > 
    - **정의**:
        - 프로세스들이 원형으로 연결되어 각 프로세스가 다음 프로세스가 점유한 자원을 요청하는 상태
    - **특징**:
        - 교착상태가 발생하기 위한 충분 조건으로, 순환 대기가 형성되지 않으면 Deadlock 발생 불가능
        - 자원 요청 순서를 지정함으로써 예방 가능
    - **동작 방식**:
        - 프로세스 P1이 자원 R1을 점유하고 R2를 요청
        - 프로세스 P2는 자원 R2를 점유하고 R1을 요청
        - 이러한 순환 구조로 인해 모든 프로세스가 대기 상태에 빠짐

### 교착상태 해결 방법 (Deadlock Handling)

**예방 (Prevention)**

- **정의**: 교착상태 발생 조건(상호 배제, 점유와 대기, 비선점, 순환 대기) 중 하나를 제거하여 교착상태 발생을 사전에 방지
- **특징**:
    - **상호 배제 부정**: 자원을 공유 가능하게 하여 배타적 접근을 제거
    - **점유와 대기 부정**: 자원을 요청하기 전, 필요한 모든 자원을 할당하거나, 자원을 점유하지 않는 경우에만 요청 가능
    - **비선점 부정**: 자원을 선점하여 다른 프로세스에 할당 가능
    - **순환 대기 부정**: 자원 요청 순서를 고정하여 순환 대기 방지
- **장점**:
    - 교착상태를 근본적으로 예방 가능
- **단점**:
    - 시스템 자원의 비효율적인 사용과 복잡한 구현 요구

**회피 (Avoidance)**

- **정의**: 교착상태를 완전히 예방하지 않고, 자원 할당 시 시스템을 안전 상태로 유지하여 교착 상태를 회피
- **특징**:
    - 프로세스의 자원 요청을 실시간으로 평가하여 안전한 경우에만 자원 할당
        - 프로세스의 수가 고정되어 있어야 함
        - 자원의 종류와 수가 고정되어 있어야 함
        - 프로세스가 요구하는 자원 및 최대 자원 수를 알아야 함
        - 프로세스는 반드시 자원을 사용 후 반납해야 함
    - 대표적인 알고리즘:
        - Banker's Algorithm
        - Resource-Allocation Graph Algorithm
    - **Safe State(안전 상태)**: 모든 프로세스가 정상적으로 종료될 수 있는 자원 상태
    - **Unsafe State(비안전 상태)**: 교착상태로 발전할 가능성이 있는 자원 상태
- **장점**:
    - 자원을 보다 효율적으로 사용 가능
- **단점**:
    - 시스템의 자원 상태와 프로세스 요청을 지속적으로 모니터링해야 하므로 복잡도가 증가

**탐지 (Detection)**

- **정의**: 교착상태가 발생했는지 확인하기 위해 주기적으로 탐지 알고리즘을 실행
- **특징**:
    - 자원 할당 그래프 또는 Wait-For 그래프를 사용하여 교착 상태를 탐지
    - 탐지 주기를 설정하여 정기적으로 확인
    - 교착 상태가 확인되면 복구 단계로 진입
- **장점**:
    - 교착 상태가 발생한 후에 해결 가능
- **단점**:
    - 탐지 과정에서 추가적인 시스템 오버헤드 발생

**복구 (Recovery)**

- **정의**: 교착상태가 탐지되었을 때, 시스템을 정상 상태로 복구하는 방법
- **특징**:
    - 프로세스를 종료하거나 자원을 회수하여 교착상태 해결
    - **희생자 선택**: 최소 피해를 줄 수 있는 프로세스를 선택하여 종료
    - **롤백**: 선점된 프로세스를 이전 상태로 복구
    - **기아 상태 방지**: 특정 프로세스가 지속적으로 선점되지 않도록 관리
- **장점**:
    - 교착상태를 해결하고 시스템을 정상 상태로 복구 가능
- **단점**:
    - 복구 과정에서 데이터 손실 또는 추가적인 성능 저하 가능
- **활용**:
    - 예방과 회피는 미리 설계된 시스템에 적합하며, 탐지와 복구는 동적 환경에서 교착상태를 해결하는 데 사용됨.

---

# 파일 시스템 (File System)

## 파일의 개념과 구조 (Concept and Structure of Files)

- **정의**:
    - 데이터를 저장하고 관리하기 위한 기본 단위로, 저장 매체에서 읽기, 쓰기, 수정이 가능한 데이터의 집합
- **특징**:
    - **비휘발성**: 스토리지에 저장되며, 전원이 꺼져도 데이터가 유지
    - **구조화된 저장**: 레코드(Record) 또는 블록(Block) 단위로 저장
    - **이름과 경로**: 파일은 고유한 이름(Name)과 경로(Path)로 식별
        - **절대경로**: 루트 디렉토리부터 시작하는 경로
        - **상대경로**: 현재 작업 디렉토리를 기준으로 하는 경로
    - **속성 정보**: 파일 크기, 생성/수정 날짜, 접근 권한 등의 메타데이터 포함
    - **시스템 호출**: 파일 생성, 삭제, 읽기/쓰기 등의 작업은 `open`, `read`, `write` 같은 시스템 호출(System Call)을 통해 수행
    - **무결성**: 파일 손상 방지를 위한 무결성(integrity) 보장
    - **공간 효율성**: 스토리지를 효율적으로 사용해야 하며, 일관성(consistency)을 유지
- **구조**:
    - **텍스트 파일**: 사람이 읽고 쓸 수 있는 문자 데이터로 구성된 파일
    - **바이너리 파일**: 실행 파일, 이미지 등 컴퓨터가 해석할 수 있는 이진 데이터로 구성
    - **특수 파일**: 장치(Device), 파이프(Pipe), 소켓(Socket) 등도 파일로 접근 가능
- **활용**:
    - 파일은 데이터 저장, 프로그램 실행, 기록 관리 등 컴퓨터 시스템 전반에서 중요한 데이터 관리 단위로 활용됨

## 디렉토리 구조 (Directory Structure)

디렉토리

- **특별한 목적으로 사용되는 파일로, 계층구조로 구성된다. (file hierachy)**

### 단일 레벨(Single Level), 다중 레벨(Multi-Level), 트리 구조(Tree Structure)

**단일 레벨 디렉토리 (Single-Level Directory)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2011.png)

> 이 그림은 **단일 레벨 디렉토리(Single-Level Directory)** 구조를 보여주며, 하나의 디렉토리 아래에 모든 파일이 저장된 형태를 나타냄
> 
- **정의**:
    - 하나의 디렉토리 아래에 모든 파일이 존재하는 구조
- **특징**:
    - 디렉토리의 수는 단일(1개)이며, 모든 파일이 이 디렉토리 내에 존재
- **장점**:
    - 구현이 간단하고, 파일 접근이 용이
- **단점**:
    - 파일 수가 많아질수록 관리가 어려움
    - 파일 이름 충돌 발생 가능

**다중 레벨 디렉토리 (Multi-Level Directory)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2012.png)

> 이 그림은 **이중 레벨 디렉토리(Two-Level Directory)** 구조를 보여주며, 각 사용자가 자신의 사용자 파일 디렉토리(User File Directory)를 가지며, 이 디렉토리는 마스터 파일 디렉토리(Master File Directory) 아래에 위치함
> 
- **정의**:
    - 중앙에 마스터 파일 디렉토리(MFD)가 있고, 그 아래 사용자별 파일 디렉토리(UFD)를 갖춘 2계층 구조
- **특징**:
    - MFD는 사용자들의 이름, 계정 번호, UFD를 가리키는 포인터를 포함
    - UFD는 한 사용자의 파일에 대한 정보만 관리
- **장점**:
    - 파일 이름 중복 문제 방지
- **단점**:
    - 사용자가 다른 사용자의 디렉토리를 검색할 수 없어 협력 및 파일 공유가 어려움

**트리 구조 디렉토리 (Tree Structure Directory)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2013.png)

> 이 그림은 트리 구조 디렉토리(Tree-Structured Directory) 구조를 보여주며, 루트 디렉토리(root) 아래에 여러 서브 디렉토리와 파일들이 계층적으로 조직되어 있는 형태를 나타냄
> 
- **정의**:
    - 하나의 루트 디렉토리와 여러 개의 서브 디렉토리로 구성된 계층적 구조
- **특징**:
    - 사용자는 서브 디렉토리를 생성하여 파일을 체계적으로 구성 가능
    - 루트 디렉토리는 파일 시스템의 최상위 디렉토리로 모든 디렉토리와 파일을 포함
    - DOS, Windows, UNIX 등 다양한 운영체제에서 사용
- **장점**:
    - 체계적인 파일 및 디렉토리 관리 가능
    - 대규모 파일 시스템에서 효율적 관리
    - 파일 이름 충돌 방지
- **단점**:
    - 구조가 복잡해질 수 있으며, 원하는 파일 탐색에 시간이 소요될 수 있음

## 파일 할당 방법 (File Allocation Methods)

### 연속 할당(Contiguous Allocation), 연결 할당(Linked Allocation), 색인 할당(Indexed Allocation)

**연속 할당(Contiguous Allocation)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2014.png)

> **연속 할당(Contiguous Allocation)** 방식으로, 파일의 데이터가 디스크 상에서 연속된 블록에 저장되어 있는 모습을 보여줌
> 
- **정의**:
    - 파일을 연속된 디스크 블록에 할당하는 방식
- **특징**:
    - 파일이 사용하는 모든 블록이 연속적으로 배치됨
    - 디스크 주소 계산이 간단하여 빠른 데이터 접근 가능
- **장점**:
    - **빠른 접근 속도**: 연속된 블록으로 구성되어 검색 시간이 짧음
    - **간단한 구현**: 파일의 시작 주소와 크기만 저장하면 관리 가능
- **단점**:
    - **외부 단편화**: 디스크 공간이 낭비될 수 있음
    - **재배치 필요성**: 파일 크기 증가 시 연속된 공간을 보장하기 위해 파일을 이동해야 할 수도 있음
    - **정확한 크기 예측 필요**: 파일 생성 시 필요한 디스크 공간 크기를 정확히 지정해야 함
- **활용 사례**:
    - 단순한 파일 시스템(예: 초기 FAT 파일 시스템)
- **예시**:
    - 파일이 4개의 블록을 필요로 하면, 디스크 상에서 블록 5, 6, 7, 8에 연속적으로 저장됨

**연결 할당(Linked Allocation)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2015.png)

> **연결 할당(Linked Allocation)** 방식으로, 파일의 각 데이터 블록이 포인터로 연결되어 비연속적으로 저장된 모습을 보여줌
> 
- **정의**:
    - 파일이 비연속적으로 저장되며, 각 블록이 다음 블록의 주소를 포함하는 방식
- **특징**:
    - 각 블록이 **포인터**를 포함하여 파일의 다음 블록을 가리킴
    - 파일 데이터가 비연속적으로 저장 가능
- **동작 방식**:
    - 파일이 4개의 블록을 필요로 하면, 블록 5 → 블록 20 → 블록 8 → 블록 15의 순서로 연결되어 저장됨
- **장점**:
    - **동적 파일 크기 조정 가능**: 파일 크기가 변동되더라도 디스크 내 비어있는 블록을 동적으로 할당 가능
    - **외부 단편화 없음**: 연속된 공간을 요구하지 않으므로 단편화 문제 해결
- **단점**:
    - **접근 속도 저하**: 포인터를 따라가며 데이터를 검색하므로 랜덤 접근 속도가 느림
    - **추가 메모리 필요**: 포인터를 저장하기 위한 추가 디스크 공간이 필요
    - **포인터 손상 가능성**: 포인터가 손상되면 파일의 나머지 데이터를 접근할 수 없음
- **활용**:
    - 데이터베이스 관리 시스템, 유연한 파일 크기 요구 시스템

**색인 할당(Indexed Allocation)**

![image.png](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20-%20%E1%84%8E%E1%85%AC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%201795752e2f2380079e0fc74b2a5ce215/image%2016.png)

> **색인 할당(Indexed Allocation)** 방식으로, 파일의 데이터 블록 주소가 인덱스 블록에 저장되어 각 데이터 블록에 접근하는 구조를 보여줌
> 
- **정의**:
    - 파일의 모든 데이터 블록 주소를 저장한 별도의 인덱스 블록을 사용하는 방식
- **특징**:
    - 파일마다 **인덱스 블록**이 존재하며, 데이터 블록의 주소를 저장
    - 데이터 블록은 **비연속적으로 저장 가능**
- **동작 방식**:
    - 파일이 4개의 블록을 필요로 하면, 인덱스 블록에 다음과 같은 정보가 저장됨:
        - 인덱스 블록: [5, 20, 8, 15]
        - 데이터 블록: 블록 5, 블록 20, 블록 8, 블록 15에 저장
- **장점**:
    - **빠른 데이터 접근**: 인덱스 블록을 참조하여 원하는 데이터 블록에 직접 접근 가능
    - **외부 단편화 없음**: 데이터 블록이 비연속적으로 저장될 수 있음
- **단점**:
    - **추가 메모리 필요**: 인덱스 블록을 저장하기 위한 디스크 공간 소모
    - **인덱스 크기 제한**: 인덱스 블록의 크기가 제한적이어서 파일 크기에 제약 발생 가능
- **활용**:
    - 대형 데이터베이스 시스템, 고속 검색이 중요한 시스템

**비교표**

| 할당 방식 | 특징 | 장점 | 단점 | 활용 사례 |
| --- | --- | --- | --- | --- |
| **연속 할당** | 연속된 블록에 파일 저장 | 빠른 접근 속도, 간단한 구현 | 외부 단편화 발생, 크기 변동 시 재배치 필요 | 단순 파일 시스템 |
| **연결 할당** | 블록 간 포인터로 연결 | 동적 크기 조정 가능, 단편화 문제 해결 | 느린 접근 속도, 포인터 손상 위험 | 유연한 파일 크기 요구 시스템 |
| **색인 할당** | 인덱스 블록에 데이터 블록 주소 저장 | 빠른 데이터 접근, 외부 단편화 없음 | 추가 메모리 필요, 인덱스 크기 제한 | 대형 데이터베이스 시스템 |

## 파일 시스템 구현 (File System Implementation)

- **정의**:
    - 파일과 디렉토리를 보조기억장치에 저장 및 접근 가능하도록 관리하는 운영체제의 프로그램
- **특징**:
    - **커널 영역에서 동작**: 운영체제의 핵심 부분에서 파일 시스템 관련 작업을 처리
    - **계층적 디렉토리 구조**: 디렉토리가 트리 구조를 이루며 파일을 관리
    - **데이터 영역과 메타 영역**:
        - 데이터 영역은 파일 내용이 저장되는 곳
        - 메타 영역은 파일 이름, 크기, 권한 등의 정보를 저장

### 디스크 스케줄링 알고리즘 (Disk Scheduling Algorithms)

**FCFS (First-Come-First-Served)**

- **정의**:
    - 디스크 요청을 도착 순서대로 처리하는 알고리즘
- **특징**:
    - **단순 구현 가능**: 요청을 순서대로 처리하므로 복잡하지 않음
    - **비효율성**: 헤드 이동이 불필요하게 길어질 가능성 있음
- **동작 방식**:
    - 디스크 헤드는 요청이 도착한 순서대로 각 요청 위치로 이동하여 처리
    - 예: 요청 큐 [98, 183, 37, 122], 초기 헤드 위치 53 → 53 → 98 → 183 → 37 → 122
- **장점**:
    - 구현이 간단하고 공정하게 모든 요청 처리 가능
- **단점**:
    - 탐색 시간이 비효율적이며 성능 예측이 어려움
- **활용**:
    - 간단한 디스크 관리 시스템
    
    ```java
    public class FCFSExample {
      public static void main(String[] args) {
        int[] requests = {98, 183, 37, 122, 14, 124, 65, 67};
        int head = 53; // 초기 헤드 위치
        for (int request : requests) {
          int movement = Math.abs(request - head);
          System.out.println("Moved from " + head + " to " + request + " (Distance: " + movement + ")");
          head = request;
        }
      }
    }
    ```
    

**SSTF (Shortest Seek Time First)**

- **정의**:
    - 현재 디스크 헤드 위치에서 가장 가까운 요청을 우선 처리하는 알고리즘
- **특징**:
    - **근접 요청 우선**: 탐색 시간이 최소화됨
    - **응답 시간 변동**: 특정 요청이 오래 대기할 가능성 있음
- **동작 방식**:
    - 현재 헤드 위치에서 가장 가까운 요청부터 처리
    - 예: 요청 큐 [98, 183, 37, 122], 초기 헤드 위치 53 → 53 → 37 → 65 → 98 → 122
- **장점**:
    - 디스크 헤드 이동이 최소화되어 탐색 시간이 단축
- **단점**:
    - 특정 요청이 장시간 대기 상태로 남을 가능성 있음 (Starvation)
- **활용**:
    - 자원이 제한적이고 탐색 시간 최소화가 중요한 시스템
    
    ```java
    import java.util.*;
    
    public class SSTF {
      public static void main(String[] args) {
        List<Integer> requestList = new ArrayList<>(Arrays.asList(98, 183, 37, 122, 14, 124, 65, 67));
        int head = 53;
        while (!requestList.isEmpty()) {
          int closestRequest = -1;
          int shortestDistance = Integer.MAX_VALUE;
          for (int request : requestList) {
            int distance = Math.abs(request - head);
            if (distance < shortestDistance) {
              shortestDistance = distance;
              closestRequest = request;
            }
          }
          System.out.println("Moved from " + head + " to " + closestRequest + " (Distance: " + shortestDistance + ")");
          head = closestRequest;
          requestList.remove(Integer.valueOf(closestRequest));
        }
      }
    }
    
    ```
    

**SCAN**

- **정의**:
    - 디스크 헤드가 한 방향으로 이동하면서 경로상의 모든 요청을 처리한 뒤, 끝에 도달하면 방향을 반대로 변경하여 요청 처리
- **특징**:
    - **연속적 요청 처리 가능**: 헤드가 한 방향으로 이동하므로 요청이 연속적으로 처리됨
    - **디스크 끝에서 방향 전환**: 끝에 도달하면 방향을 반대로 변경
- **동작 방식**:
    - 헤드가 0에서 디스크의 끝으로 이동하며 요청 처리, 끝에 도달하면 반대 방향으로 이동하며 나머지 요청 처리
    - 예: 요청 큐 [98, 183, 37, 122, 14], 초기 헤드 위치 53 → 53 → 65 → 98 → 122 → 183 → 방향 전환
- **장점**:
    - 요청 처리 효율이 높고 탐색 시간 균형 유지 가능
- **단점**:
    - 디스크 끝까지 이동 후 다시 돌아오는 시간이 추가로 소요됨
- **활용**:
    - 대규모 데이터 처리 시스템, 다중 요청 처리 환경
    
    ```java
    import java.util.*;
    
    public class SCAN {
      public static void main(String[] args) {
        List<Integer> requestList = new ArrayList<>(Arrays.asList(98, 183, 37, 122, 14, 124, 65, 67));
        int head = 53;
        int diskSize = 200;
        boolean direction = true; // true: 오른쪽, false: 왼쪽
    
        Collections.sort(requestList);
    
        while (!requestList.isEmpty()) {
          if (direction) {
            Iterator<Integer> iterator = requestList.iterator();
            while (iterator.hasNext()) {
              int request = iterator.next();
              if (request >= head) {
                int distance = Math.abs(request - head);
                System.out.println("Moved from " + head + " to " + request + " (Distance: " + distance + ")");
                head = request;
                iterator.remove();
              }
            }
            System.out.println("Reached end of disk at position " + (diskSize - 1));
            head = diskSize - 1;
            direction = false;
          } else {
            ListIterator<Integer> iterator = requestList.listIterator(requestList.size());
            while (iterator.hasPrevious()) {
              int request = iterator.previous();
              if (request <= head) {
                int distance = Math.abs(request - head);
                System.out.println("Moved from " + head + " to " + request + " (Distance: " + distance + ")");
                head = request;
                iterator.remove();
              }
            }
            System.out.println("Reached start of disk at position 0");
            head = 0;
            direction = true;
          }
        }
      }
    }
    
    ```
    

**C-SCAN (Circular SCAN)**

- **정의**:
    - 헤드가 한 방향으로 이동하며 요청을 처리하고, 끝에 도달하면 다시 처음으로 이동하여 같은 방향으로 요청 처리
- **특징**:
    - **SCAN의 변형**: 헤드가 한 방향으로만 이동하여 요청 처리
    - **끝에서 처음으로 이동**: 디스크 끝에 도달하면 다시 처음으로 이동하며 처리
- **동작 방식**:
    - 헤드는 요청 큐를 따라 한 방향으로만 이동하며 요청 처리
    - 예: 요청 큐 [98, 183, 37, 122, 14], 초기 헤드 위치 53 → 53 → 65 → 98 → 122 → 183 → 0으로 이동 후 다시 시작
- **장점**:
    - 요청 처리 간의 균형 유지 가능
- **단점**:
    - 끝에서 처음으로 이동 시 추가적인 오버헤드 발생
- **활용**:
    - 실시간 시스템, 지속적인 디스크 접근이 요구되는 환경
    
    ```java
    import java.util.*;
    
    public class CSCAN {
      public static void main(String[] args) {
        List<Integer> requestList = new ArrayList<>(Arrays.asList(98, 183, 37, 122, 14, 124, 65, 67));
        int head = 53;
        int diskSize = 200;
    
        Collections.sort(requestList);
    
        while (!requestList.isEmpty()) {
          Iterator<Integer> iterator = requestList.iterator();
          while (iterator.hasNext()) {
            int request = iterator.next();
            if (request >= head) {
              int distance = Math.abs(request - head);
              System.out.println("Moved from " + head + " to " + request + " (Distance: " + distance + ")");
              head = request;
              iterator.remove();
            }
          }
          System.out.println("Reached end of disk. Moving to start position 0.");
          head = 0;
        }
      }
    }
    
    ```
    

**비교표**

| 알고리즘 | 정의 | 특징 | 장점 | 단점 | 활용 사례 |
| --- | --- | --- | --- | --- | --- |
| **FCFS** | 요청 도착 순서대로 처리 | 단순 구현 가능, 비효율적 | 구현 용이, 공정한 요청 처리 | 탐색 시간 증가 | 간단한 디스크 관리 |
| **SSTF** | 가장 가까운 요청부터 처리 | 근접 요청 우선, 응답 시간 변동 | 탐색 시간 단축 | Starvation 가능성 | 탐색 시간 최소화 필요 |
| **SCAN** | 헤드가 한 방향으로 이동하며 요청 처리 후 방향 변경 | 연속적 요청 처리 가능 | 효율적 요청 처리 | 끝에서 방향 전환 오버헤드 | 다중 요청 처리 환경 |
| **C-SCAN** | 한 방향으로 이동 후 끝에서 처음으로 이동 | 요청 간 균형 유지 가능 | 응답 시간 균형 | 끝에서 처음 이동 오버헤드 | 실시간 시스템, 연속 작업 |

### 파일 시스템 무결성 (File System Integrity)

- **정의**:
    - 데이터 손상, 비정상 종료, 하드웨어 오류 등으로 인해 파일 시스템의 일관성이 깨지는 문제를 방지하고 복구하는 능력을 의미
- **중요성**:
    - 데이터 손실 방지
    - 시스템 안정성 확보
    - 하드웨어 및 소프트웨어 오류 발생 시 복구 가능성 제공

**저널링(Journaling)**

- **정의**:
    - 데이터를 변경하기 전에 해당 변경 내용을 로그(저널)에 기록하여, 비정상 종료 시 로그를 기반으로 복구하는 기법
- **특징**:
    - 데이터 변경 전 **의도**를 기록하여 데이터의 일관성을 유지
    - WAL (Write-Ahead Logging)이라고도 불림
    - 비정상 종료 후 **Redo** 또는 **Undo**를 통해 복구
- **종류**:
    - **Data Journaling**:
        - 사용자 데이터와 메타데이터를 모두 저널에 기록
        - 데이터의 높은 안정성을 보장하지만 성능이 저하될 수 있음
    - **Metadata Journaling**:
        - 사용자 데이터는 기록하지 않고 메타데이터만 저널링
        - 성능과 안정성의 균형을 제공
        - 메타데이터 저널링 방식에는 다음 두 가지가 있음:
            - **Ordered Journaling**:
                - 사용자 데이터를 먼저 쓰고 메타데이터를 기록
                - 데이터 손상 방지를 위해 기본적으로 사용되는 방식 (e.g., ext3, ext4)
            - **Writeback Journaling**:
                - 데이터와 메타데이터의 순서 보장을 하지 않음
                - 성능을 우선시하며 NTFS에서 사용
- **동작 방식**:
    - **저널링 단계**:
        - 데이터 변경 내용을 저널에 기록 (TxB, 데이터, TxE)
        - 저널에 기록이 완료되면 **체크포인팅**을 통해 원래 위치에 데이터를 저장
    - **복구 과정**:
        - 비정상 종료 시 저널의 **TxB**와 **TxE**를 확인하여 완료되지 않은 작업은 **Undo**, 완료된 작업은 **Redo**
- **장점**:
    - 빠른 복구 가능
    - 데이터 손상 방지
    - 순차적 쓰기와 비동기적 체크포인팅으로 성능 향상
- **단점**:
    - 저널링 및 체크포인팅으로 인해 쓰기 작업의 오버헤드 발생
    - Data Journaling은 성능 저하가 클 수 있음
- **활용**:
    - **Ext3/Ext4**:
        - **Ext3**: Metadata Journaling 도입
        - **Ext4**: Extent(가변 크기 블록) 도입으로 대규모 파일 성능 개선
    - **NTFS**:
        - Writeback Journaling을 사용하여 성능 우선
    - **ReiserFS**, **XFS**, **JFS**:
        - 각각의 운영 체제나 용도에 맞게 최적화된 저널링 파일 시스템

**RAID (Redundant Array of Independent Disks)**

- **정의**:
    - 여러 개의 물리적 하드 디스크를 결합하여 하나의 논리적 드라이브로 구성하는 기술
    - 데이터 보존성과 성능 향상을 목표로 설계된 저장 장치 구성 방식
- **특징**:
    - **하나의 논리적 드라이브**: 외부에서는 RAID가 하나의 디스크처럼 보임
    - **다양한 레벨**: RAID 0, RAID 1, RAID 5, RAID 6, RAID 10 등 여러 레벨로 데이터 저장 방식 제공
    - **분산 저장**: 데이터를 여러 디스크에 분산하거나 복제, 패리티 데이터를 생성해 안정성과 성능 제공
    - **구성 요소**:
        - 여러 개의 물리적 디스크
        - RAID 컨트롤러(하드웨어 또는 소프트웨어)
        - 데이터를 관리하기 위한 메모리와 프로세서
- **동작 방식**:
    - **RAID 0 (Striping)**:
        - 데이터를 여러 디스크에 분산 저장하여 읽기/쓰기 성능 향상
        - 데이터 복구 불가능 (내결함성 없음)
    - **RAID 1 (Mirroring)**:
        - 데이터를 디스크에 복제하여 높은 가용성과 안정성 제공
        - 디스크 용량 효율성이 낮음
    - **RAID 5 (Striping with Parity)**:
        - 데이터를 디스크에 분산 저장하고, 패리티 데이터를 통해 내결함성 제공
        - 한 개의 디스크 고장 시 데이터 복구 가능
    - **RAID 6**:
        - RAID 5와 유사하지만 패리티 데이터를 두 개 생성하여 두 개의 디스크 고장도 복구 가능
    - **RAID 10 (1+0)**:
        - RAID 1과 RAID 0을 결합한 방식으로, 데이터 복제와 분산 저장 제공
- **장점**:
    - **성능 향상**: 디스크 여러 개를 병렬적으로 사용하여 읽기/쓰기 속도 개선
    - **데이터 안정성**: 일부 디스크 고장 시 데이터 복구 가능
    - **확장성**: 더 많은 디스크를 추가하여 용량을 확장 가능
- **단점**:
    - **비용 증가**: 여러 디스크와 RAID 컨트롤러 필요
    - **복잡한 관리**: RAID 배열 설정 및 관리를 위해 추가적인 기술 필요
    - **RAID 0의 데이터 손실 위험**: 내결함성이 없으므로, 디스크 하나라도 손상되면 데이터 복구 불가
- **활용**:
    - **서버 환경**: 데이터 손실이 치명적인 데이터 센터, 클라우드 스토리지
    - **고성능 컴퓨팅**: 높은 읽기/쓰기 속도가 필요한 작업 (예: 데이터 분석, 비디오 편집)
    - **백업 및 데이터 복구**: 데이터 가용성과 내구성을 보장해야 하는 환경