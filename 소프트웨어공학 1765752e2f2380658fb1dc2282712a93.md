# 소프트웨어공학

정의, 특징, 동작방식, 장단점, 활용(예시)

# 소프트웨어 공학 개요

### 소프트웨어 공학의 정의와 목적

- 정의:
    - 소프트웨어를 개발하기 위해 요구사항 분석부터 유지보수까지 또는 개발과정부터 관리까지 전 과정을 체계적으로 관리하는 방법론.
- 목적:
    
    소프트웨어 개발에 공학적 접근 방법을 적용하는 궁극적인 목표는 다음과 같다.
    
    1. 복잡도 낮춤
        - 대규모 소프트웨웨어는 복잡하고 개발하기 어렵다. 이를 해결하기 위해 소프트웨어 공학은 큰 문제를 소규모의 작은 문제로 나누는 방법을 제공한다.
    2. 비용 최소화
        - 소프트웨어 개발에는 많은 인력과 비용이 필요하다. 필요하지 않은 일이나 중복되는 일을 최소화하기 위한 여러 작업 방법이 있다.
    3. 개발 기간 단축
        - 개발 작업을 잘 계획하고 관리하면 개발 기간을 상당히 단축할 수 있다.
    4. 대규모 프로젝트 관리
        - 프로젝트의 게획, 관리 등 공학적 접근을 돕는다.
    5. 고품질 소프트웨어
        - 소프트웨어는 주어진 기간 동안 잘 작동된다는 신뢰성이 보장되어야 한다. 결함이 있다면 해결되어야 하므로 시험과 유지보수 작업 방법이 필요하다.
    6. 효율성
        - 소프트웨어 공학적 접근법은 표준화에 도움이 되어 작업 효율이 높아진다.
- 최종 목표
    - 개발 대상의 명확화, 체계화, 수명 주기 지원을 통해
    - 사용자 요구사항을 충족시키는 품질 좋은 소프트웨어를 최소의 비용으로 계획된 일정에 맞추어 개발하는 것.
        
        ![image.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/image.png)
        

### 소프트웨어의 특징과 복잡성

- 정의
    - 입력된 자료를 처리하여 결과를 출력하는 프로그램과 프로그램의 개발, 운용, 유지보수에 필요한 관련되는 정보 일체.
- 종류
    - 소프트웨어는 세가지 유형(주문형 소프트웨어, 패키지 소프트웨어, 임베디드 소프트웨어)으로 분류된다.
    
    | 소프트웨어 분류 | 특징 | 사용되는 카피 수 | 요구되는 하드웨어 성능 | 개발 인력 |
    | --- | --- | --- | --- | --- |
    | 1. 주문형 소프트웨어 | 특정 고객 또는 기업의 요구를 만족시키기 위해 제작한 소프트웨어 | 적음 | 낮음 | 많음 |
    | 2. 패키지 소프트웨어 | 패키지화하여 상업적으로 판매하는 소프트웨어 | 중간 | 높음 | 중간 |
    | 3. 임베디드 소프트웨어 | 다른 시스템에 내장된 소프트웨어 | 많음 | 중간 | 적음 |
- 특징
    1. 상품성
        - 개발이 완료된 소프트웨어는 상품화된다.
    2. 견고성
        - 소프트웨어의 부분적 수정으로 소프트웨어 전체에 영향을 미칠 수 있으므로 수정이나 변경이 용이하지 않다.
    3. 복잡성
        - 개발 과정은 복잡하고 까다롭기 때문에 산출물에 대한 표준화가 필요하다.
    4. 순응성
        - 사용자의 요구사항이나 환경 변화에 맞춰 빠르게 변경할 수 있다.
    5. 비가시성
        - 개발이 완료될 때까지는 소프트웨어 결과물이 어떠한 지 알 수 없고, 완성되기 전까지는 코드에 의존한다.
    6. 비마모성
        - 소프트웨어는 마모되거나 없어지지 않는다.
    7. 비제조성
        - 하드웨어는 제작하지만, 소프트웨어는 논리적인 사고를 가지고 개발한다.
    8. 비과학성
        - 소프트웨어 개발을 위해서는 시간, 인력, 노력이 필요하며 절차 중심이다.
    9. 복제성
        - 소프트웨어는 무한하게 복제가 가능하다.
            - 단, 저작권 문제는 고려가 필요하다.
- 복잡성
    - 정의
        - 시스템이나 구성요소의 설계와 구현이 얼마나 복잡하게 얽혀 있는지를 나타내는 특성.
    - 특징
        - 국제 표준 ISO/IEC 25010:2011에 따르면 복잡성은 **소프트웨어 품질 특성** 중 유지보수성과 밀접하게 연관된다.
        - 소프트웨어 개발, 유지보수, 확장성을 어렵게 만드는 요인으로 작용한다.
        - 구조적 복잡성:
            - 설계 구조와 구성요소 간 관계에서 발생한다.
        - 논리적 복잡성:
            - 프로그램의 조건문, 반복문, 예외 처리 등 제어 흐름에서 발생한다.
        - 계산적 복잡성:
            - 알고리즘의 시간 복잡도와 공간 복잡도에서 발생한다.
        - 상호 의존성:
            - 모듈 간 강한 의존성이나 데이터 흐름에서 오는 복잡성이다.
        - 확장성 문제:
            - 복잡성이 높아질수록 새로운 요구사항 반영이 어려워진다.

### 소프트웨어 개발의 중요성과 도전 과제

- 핵심 활동의 중요성
    - 소프트웨어 개발은 명세화, 구현, 검증, 유지보수의 네 가지 기본 활동을 통해 이루어진다. 이 과정은 단순한 프로그램 작성이 아니라, 사용자의 요구사항을 효과적으로 해결하는 시스템을 만드는 것을 목표로 한다.
        - **명세화**: 고객의 요구를 명확히 정의하고 분석하여 구현 계획을 세운다.
        - **구현**: 명세화된 요구사항을 기반으로 소프트웨어를 설계하고 코드를 작성한다.
        - **검증**: 구현된 소프트웨어가 명세를 충족하며 오류가 없는지 확인한다.
        - **유지보수**: 출시 이후 사용자 요구사항의 변화와 오류 수정을 처리한다.
    
    ![출처: 소프트웨어 공학의 모든 것-최은만](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/image%201.png)
    
    출처: 소프트웨어 공학의 모든 것-최은만
    
- 사회적, 경제적 중요성
    - **사회적 영향**: 소프트웨어는 **스마트폰, 웹 서비스, 공공 시스템** 등 다양한 분야에서 현대 사회를 지탱하는 필수 요소이다.
    - **경제적 가치**: 효율적인 소프트웨어는 **비용 절감과 생산성 향상**을 가능하게 하며, 기업의 경쟁력을 강화한다.
    - **기술적 혁신**: 인공지능, 클라우드, IoT 등 첨단 기술의 기반은 소프트웨어로부터 시작된다.
- 도전 과제
    - 소프트웨어 위기
        - 정의: 소프트웨어의 수요가 급격히 증가하고 그 복잡성이 증가함에 따라 기존 방법이 충분하지 않아 발생한 문제.
        - 원인:
            - 소프트웨어 규모 대형화 및 복잡도 증가 → 개발 비용 증대
            - 소프트웨어 개발 프로젝트 기간 및 소요 예산 예측의 어려움
            - 소프트웨어에 대한 사용자 요구사항의 빈번한 변경 및 반영
            - 소프트웨어 유지 보수의 어려움과 개발 정체 현상 발생
            - 사용자의 소프트웨어에 대한 기대치 증가
            - 신기술에 대한 교육 및 훈련 부족
                
                ![스크린샷 2025-01-09 오후 7.22.42.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.22.42.png)
                
                소프트웨어 위기의 원인은 위 그림처럼 요구 증가, 복잡도 증가, 난이도 증가 등으로 인해 발생하며, 기존의 동일한 인력, 방법, 도구로는 이를 해결하기 어렵다.
                
        - 의의: 소프트웨어 위기 발생으로 새로운 소프트웨어 개발 방법의 필요성을 인식.

### 소프트웨어 공학의 발전 과정

- 1970년대 초: 구조적 프로그래밍
    - 프로그램을 체계적으로 작성하기 위한 구조적 코딩 방식이 도입되었다.
    - 하향식 프로그래밍, 정보 은닉, 추상화, 그리고 문제를 작은 단위로 나누는 단계적 세분화 기법이 사용되었다.
- 1970년대 중반: 설계 방법론
    - 개발 초기 설계의 중요성이 강조되며, 구조적 설계와 JSP(개념적 설계 방법론) 같은 설계 기법이 등장했다.
        - 이는 설계 단계에서 오류를 줄이는 데 기여했다.
- 1970년대 말: 분석 방법론
    - 요구사항을 체계적으로 분석하기 위해 구조적 분석과 SADT(구조적 분석 및 설계 기법) 같은 도구가 사용되기 시작했다.
- 1980년대 초: 자동화 도구와 객체지향 프로그래밍
    - 소프트웨어 개발을 지원하는 PSL/PSA 같은 자동화 도구와 코드 자동 생성 기술이 도입되었다.
    - Smalltalk와 C++을 기반으로 객체지향 프로그래밍 패러다임이 본격적으로 자리 잡기 시작했다.
- 1980년대 말: 응용 소프트웨어 공학
    - 대화형 그래픽 도구를 통한 분석과 설계 지원이 활성화되었다.
    - 프로그래밍 환경과 통합 소프트웨어 공학 도구, 사용자 인터페이스 관리 시스템(UIMS) 등이 개발되었다.
- 1990년대 초: 객체지향 소프트웨어 공학
    - 객체지향 프로그래밍이 분석과 설계 단계로 확장되었고, Booch, OMT와 같은 분석 및 설계 기법이 도입되었다.
    - 기존 소프트웨어를 재구조화하는 소프트웨어 리엔지니어링 개념이 강조되었다.
- 1990년대 중반: 객체지향 분산처리
    - 객체지향 기법이 분산처리 시스템으로 확장되며, 소프트웨어 재사용, 설계 패턴 활용, Java를 통한 분산 객체 프로그래밍이 활성화되었다.
- 2000년대 초: 컴포넌트 개발과 애자일 방법론
    - 컴포넌트를 중심으로 개발하는 방법론이 등장했다.
    - 변화에 민첩하게 대응하기 위한 익스트림 프로그래밍(XP)과 애스펙트 중심 프로그래밍(AOP)이 개발 방식으로 채택되었다.
- 2000년대 중반: 웹 서비스와 SOA
    - 웹 서비스 기술이 확장되었으며, 서비스 지향 아키텍처(SOA)가 분산 시스템에서 유연성을 제공하는 아키텍처로 자리 잡았다.
- 2010년대 이후: 클라우드와 DevOps
    - 클라우드 컴퓨팅(AWS, Azure)을 활용한 개발이 보편화되었고, 지속적 통합/배포(CI/CD)를 지원하는 DevOps가 소프트웨어 개발과 운영을 통합하는 핵심 방식이 되었다.

# 소프트웨어 개발 생명 주기 (SDLC)

### SDLC 모델의 개념

- 정의
    - 소프트웨어 개발 생명주기 (Software Development Life Cycle)은 소프트웨어를 만들기 위해 계획 단계부터 유지보수 단계에 이르기까지 일어나는 일련의 과정이다.
- 특징
    - SDLC는 일반적으로 다음과 같은 계획, 요구사항 분석, 설계, 구현, 테스트, 배포, 유지보수 7개의 주요 단계로 구성된다:
        
        ![image.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/image%202.png)
        
        1. 계획
            - 개발할 소프트웨어를 정의하고 소프트웨어 개발의 필요성에 대한 타당성을 검증한다.
            - 개발에 필요한 비용 및 인력을 산정하고, 일정 계획, 위험 분석 및 대책을 수립한다.
        2. 요구사항 분석
            - 개발할 소프트웨어의 기능과 제약조건, 목표 등을 사용자와 함께 정의한다.
        3. 설계
            - 소프트웨어 구조를 논리적으로 결정한다.
        4. 구현
            - 논리적으로 결정된 구조를 프로그래밍 언어를 통해 실제 프로그램으로 작성한다.
        5. 테스트
            - 개발한 소프트웨어가 요구사항을 만족하는지와 결과가 정학한지를 평가한다.
        6. 배포
            - 완성된 소프트웨어를 인수하기 위해 실제 데이터를 사용해 최종 평가를 한다.
        7. 유지보수
            - 소프트웨어가 인수/납품/배포된 후 일어나는 모든 활동이다.
            - 소프트웨어 개발 생명주기 중 가장 긴 기간을 차지한다.
    - 이러한 단계들은 순환적으로 반복되며, 각 단계는 다음 단계로 자연스럽게 이어진다.

### 전통적 SDLC 모델

- 폭포수 모델
    - 정의:
        - 소프트웨어 공학의 기본이 되는 전통적인 개발 모델로, 계획, 분석, 설계, 구현, 테스트, 유지보수의 단계를 순차적으로 진행한다.
    - 특징:
        - 단계별 산출물 작성: 각 단계에서 개발 계획서, 요구분석 명세서, 설계서 등 산출물을 작성한다.
        - Top-Down 방식: 상위 단계에서 하위 단계로 흐르며, 이전 단계가 완료된 후에만 다음 단계로 진행할 수 있다.
        - 표준화된 프로세스: 공장의 생산 라인처럼 표준화된 작업 프로세스를 통해 순차적으로 소프트웨어를 개발한다.
    - 장점:
        - 정형화된 절차로 인해 프로젝트 관리가 체계적으로 이루어진다.
        - 각 단계에서 문서를 작성해 체계적으로 문서화하여 관리할 수 있다.
        - 요구사항의 변화가 적은 프로젝트에 적합하며, 단계별로 명확한 진행을 보장한다.
    - 단점:
        - 각 단계는 이전 단계가 완료된 후에만 진행할 수 있어 유연성이 부족하다.
        - 각 단계에서 작성된 결과물이 완벽해야 이후 단계에서 오류가 발생하지 않으므로 초기 계획과 분석의 정확도가 중요하다.
        - 사용자가 개발 중간에 가시적인 결과를 확인할 수 없어 피드백이 어렵다.
- V-모델
    - 정의
        - V(Verification) 모델은 폭포수 모델의 변형으로, 테스트 단계를 추가 확장한다. 테스트 단계가 분석 및 설계와 어떻게 관련되어 있는지를 나타낸다.
    - 특징
        - 폭포수 모델이 산출물 중심이라면, V 모델은 각 단계의 검증에 초점을 둔다.
            
            ![image.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/image%203.png)
            
        - 단계별 테스트 유형
            - 단위 테스트: 구현 단계에서 프로그램 개발자에 의해 수행된다.
            - 통합 테스트: 모듈을 결합, 하나의 시스템으로 구성해 테스트한다.
            - 시스템 테스트: 통합 모듈에 대한 시스템적(비기능적 테스트)
            - 인수 테스트: 사용자의 만족 여부를 테스트하는 품질 테스트이다.
            - 설치 테스트: 시스템을 설치하면서 수행한다. HW-SW 연결성 등을 테스트한다.
    - 장점
        - 세세한 테스팅으로 결과물의 오류를 줄일 수 있다.
        - 높은 신뢰도를 요구하는 프로젝트에 적합하다.
    - 단점
        - 폭포수 모델과 마찬가지로 반복이 없으므로 변경 사항을 다루기 어렵다.

### 현대적 SDLC 모델

- 애자일(Agile) 프로세스 모델
    - 정의:
        - 사용자 요구사항에 중점을 두어 문서화를 최소화한 시스템을 구현하여 사용자에게 빠르게 소프트웨어를 제공할 수 있는 방법.
    - **특징**:
        - **변화 수용**: 사용자 요구사항의 변경에 유연하게 대응할 수 있다.
        - **짧은 주기**: 반복적인 개발 주기를 통해 사용 가능한 소프트웨어를 자주 전달한다.
        - **협력 강조**: 고객과의 협력 및 팀원 간 상호작용을 중시한다.
        - **성과 중심**: 문서보다는 작동 가능한 소프트웨어를 더 중요하게 여긴다.
    - **장점**:
        - 요구사항 변경에 신속히 대응할 수 있다.
        - 고객과 지속적인 소통을 통해 높은 만족도를 제공할 수 있다.
        - 짧은 주기를 통해 빠른 피드백과 오류 수정을 가능하게 한다.
    - **단점**:
        - 경험이 부족한 팀에서는 비효율적으로 운영될 가능성이 있다.
- 스크럼(Scrum)
    - 정의:
        - 애자일 방법론의 대표적인 프레임워크로, 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리에 중점을 둔 방법론.
    - 특징
        - **역할 구성**: 스크럼은 제품 책임자(Product Owner), 스크럼 마스터(Scrum Master), 개발 팀(Development Team)으로 구성된다.
            - **제품 책임자 (Product Owner)**: 제품의 개발 방향과 우선순위를 설정하며, 고객과 협력해 요구사항을 수집하고 **제품 백로그**를 관리.
            - **스크럼 마스터 (Scrum Master)**: 스크럼 프로세스가 원활하게 진행되도록 돕는 역할로, 장애물을 제거하고 팀의 생산성을 높임.
            - **개발 팀 (Development Team)**: 크로스 기능 팀으로 구성되며, 실제 소프트웨어를 개발하고 구현하는 역할을 담당.
        - **프로세스 중심**: 스크럼은 정해진 다음과 같은 과정으로 진행된다.
            
            ![image.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/image%204.png)
            
            - **스프린트 계획(Sprint Planning)**:
                - 각 스프린트의 목표를 설정하고, 수행할 작업을 **스프린트 백로그**에 추가한다.
            - **데일리 스크럼(Daily Scrum)**:
                - 매일 진행되는 약 15분 간의 짧은 미팅으로, 진행 상황을 공유하고 장애물을 논의한다.
            - **스프린트 리뷰(Sprint Review)**:
                - 스프린트가 끝난 후, 산출물을 검토하고 이해관계자의 피드백을 받는 과정이다.
            - **스프린트 회고(Sprint Retrospective)**:
                - 스프린트 종료 후, 개선할 점과 성공적인 점을 논의하여 다음 스프린트를 준비한다.
        - **반복 주기**:
            - 스크럼은 1~4주의 짧은 반복 주기로 작업을 진행하며, 각 스프린트가 끝날 때마다 작동 가능한 소프트웨어를 산출한다.
        - **주요 산출물**:
            - **제품 백로그 (Product Backlog)**:
                - 제품에서 구현해야 할 모든 요구사항의 목록으로, **제품 책임자**가 우선순위를 정한다.
            - **스프린트 백로그 (Sprint Backlog)**:
                - 특정 스프린트 동안 수행할 작업의 목록으로, **스프린트 계획 회의**에서 개발 팀이 선정한다.
            - **소멸 차트 (Burndown Chart)**:
                
                ![스크린샷 2025-01-09 오후 8.35.00.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.35.00.png)
                
                - 스프린트 기간 동안 남아있는 작업량을 시각적으로 보여주는 차트로, 팀의 작업 진척 상황을 파악하는 데 사용된다.
    - 장점
        - 반복 주기마다 실행 가능한 제품을 통해 사용자와 충분히 의견을 교환할 수 있다.
        - 매일 진행되는 스크럼 회의를 통해 팀원 간 신속한 협조와 조율이 가능하다.
        - 팀원이 자신의 일정을 발표함으로써 업무에 대한 집중도를 높일 수 있다.
        - ****다른 개발 방법론에 비해 구조가 단순하며 실천 가능성이 높다.
        - 스크럼 마스터가 팀의 장애물을 제거하고 팀원들이 목표 달성에 집중하도록 돕는다.
        - 프로젝트 진행 현황을 시각적으로 확인할 수 있어 목표와 결과를 신속히 추정할 수 있다.
        - 진행 상황에 따라 목표를 조정하거나 변화를 시도할 수 있다.
    - 단점
        - 반복 주기가 끝날 때마다 실행 가능하고 테스트 가능한 제품을 만들어야 하므로 작업량이 많아질 경우 시간이 더 필요하다.
        - 일일 스크럼 회의 시간이 길어지면 작업 시간이 지연되고, 업무에 방해가 될 수 있다.
        - 작업량에 대한 투입 공수를 측정하지 않으므로 작업이 얼마나 효율적으로 수행되었는지 알기 어렵다.
        - 프로세스 품질을 평가하지 않으므로 결과물의 품질 정도를 명확히 알기 어렵다.
- 칸반(Kanban)
    - **정의**:
        
        작업의 시각화를 통해 진행 상황과 작업 흐름을 한눈에 파악하고, 작업량을 제한하여 팀의 효율성을 극대화하는 방법론.
        
    - **특징**:
        - **칸반 보드**: 작업을 "할 일(To Do)", "진행 중(In Progress)", "완료(Done)"와 같은 열로 나누어 시각적으로 관리한다.
        - **작업 제한(WIP Limit)**: 한 번에 처리할 수 있는 작업량을 제한하여 과부하를 방지한다.
        - **지속적 개선**: 작업 흐름을 지속적으로 최적화하고 팀의 생산성을 향상시킨다.
        - **유연성**: 특정 개발 주기를 고정하지 않으며, 필요할 때 작업을 추가하거나 수정할 수 있다.
    - **장점**:
        - 작업의 흐름과 진행 상황을 명확히 파악할 수 있다.
        - 작업량 제한으로 과부하를 방지하고 팀의 안정성을 유지할 수 있다.
        - 간단하고 유연한 방식으로 팀의 생산성을 높일 수 있다.
    - **단점**:
        - 명확한 일정 관리가 어려울 수 있다.
        - 작업의 우선순위 설정이 제대로 이루어지지 않으면 비효율적으로 작동할 수 있다.
        - 작은 팀에서는 효과적이지만, 팀 규모가 커지면 복잡성이 증가할 수 있다.

# 요구사항 분석

### 요구사항의 정의와 중요성

- 요구사항
    - 정의:
        - 사용자와 개발자가 합의한 범위 내에서 필요로 하는 기능.
    - 특징
        - 요구사항은 **소프트웨어 개발 수명주기에서 가장 중요한 요소**로, 프로젝트 실패의 주요 원인이 되는 명확하지 않은 정의를 방지한다.
        - 다양한 이해관계자로부터 도출하며, 소프트웨어가 무얼 해야 하는가를 표현한다.
        - 초기 요청보다 **상세하고 구체적인 요구사항 목록**으로 발전하며, 고객과 개발자 간의 **의사소통 도구**로 사용된다.
        - 요구사항 정의는 지속적으로 변화하며, 문제점을 늦게 발견하면 **수정 비용이 크게 증가**할 수 있다.
        - 요구사항은 **기능 요구사항**과 **비기능 요구사항**으로 나뉜다.

### 기능 요구 사항과 비기능 요구 사항

- **기능 요구사항**
    - 정의:
        - 사용자 업무 처리와 직접 관련되어 소프트웨어 시스템이 수행해야 할 **기능적 동작**을 정의하는 요구사항
    - 특징:
        - 사용자는 시스템을 통해 기능을 제공받기를 바라고, 시스템은 사용자에게 필요한 기능을 제공한다.
        - 사용자가 원하는 기능은 완전하고 일관성 있게 표현해야 하며, 시스템에도 전부 반영해야 한다.
    - 예시:
        - 로그인, 데이터 저장, 보고서 생성.
- **비기능 요구사항**
    - 정의:
        - 소프트웨어 시스템이 제공하는 기능과는 직접적으로 관련되지 않지만, 시스템의 **행위적 속성**(성능, 안정성, 보안 등)을 정의하는 요구사항
    - 특징:
        - 소프트웨어의 **품질**과 사용성을 결정하는 중요한 요소이다.
        - 시스템이 어떻게 작동해야 하는지를 명확히 한다.
        - 다음과 같은 종류가 있다:
            - **운영 요구사항**: 시스템의 환경 및 실행 조건.
            - **지원 요구사항**: 시스템의 유지보수 및 관리,
            - **성능 요구사항**: 처리 속도, 응답 시간, 처리량 등.
            - **보안 요구사항**: 데이터 보호, 접근 제어 등.
            - **문화적/정책적 요구사항**: 지역적 규제 및 정책 준수.
    - 예시:
        - 플랫폼 호환성, 로그 및 모니터링, 응답시간 2초 이내, 암호화 방식, 언어 지원.

### 요구 사항 수집 기법

![스크린샷 2025-01-09 오후 9.08.14.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.08.14.png)

> 자료 수집 → 요구사항 도출 → 문서화 → 검증 단계 중 첫번째 단계에 해당한다.
> 
- **인터뷰**
    - 정의: 사용자 또는 이해관계자와 직접 대화하여 요구사항을 수집하는 방법.
    - 특징:
        - 대면 수집 방법으로 다음과 같은 과정으로 수행한다.
            - 인터뷰 준비 단계: 인터뷰 대상자 선정 → 인터뷰 계획 수립 → 인터뷰 준비
            - 인터뷰 실시 단계: 인터뷰 시작 → 인터뷰 실시 → 인터뷰 종료
            - 인터뷰 정리 단계: 인터뷰 결과 정리 → 결과 공지 → 인터뷰 과정 평가
    - **장점**: 상세하고 구체적인 정보를 획득할 수 있다.
    - **단점**: 시간과 비용이 많이 소요될 수 있다.
- **설문**
    - 정의: 다수의 이해 당사자들에게 질문을 작성하여 요구사항을 찾아내는 방법.
    - 특징:
        - 다음과 같은 과정으로 진행된다:
            - 설문 대상 선정 → 설문 문항 작성 → 설문지 회수 방법
        - 다음 사항에 유의하여야 한다:
            - 질문은 간단하여야 하고 중요한 이슈에 집중한다.
            - 가능하면 다른 이해 당사자 그룹에 대해 다른 설문지를 준비한다.
            - 고객을 대표하여 질문이 적절하고 잘 기술되었는지 확인하게 한다.
    - **장점**:
        - 빠르게 많은 데이터를 수집할 수 있다.
        - 이해 당사자들이 의사결정 과정에 포함된다.
        - 무기명 설문은 이해 당사자들이 관심과 내부 정보, 개선 의견을 나타내기에 좋다.
    - **단점**:
        - 설문지에 어떤 문제에 대한 옵션이 언급되지 않은 경우 답변이 없는 상태로 남을 수 있다.
- **관찰**
    - 정의: 사용자의 업무 환경을 직접 관찰하여 요구사항을 도출하는 방법.
    - **장점**: 사용자의 실제 행동을 이해 가능하다.
    - **단점**: 시간 소모가 크고 주관적 해석 가능성 있다.
- **워크숍**
    - 정의: 이해관계자와 개발팀이 모여 논의하며 요구사항을 수집하는 방법.
    - **장점**: 협업을 통해 다양한 관점을 반영할 수 있다.
    - **단점**: 조율 과정에서 갈등이 발생할 수 있다.

### 요구사항 명세서 작성

- **요구 분석 명세서 (SRS: Software Requirement Specification)**
    - 정의:
        - 요구사항을 체계적이고 명확하게 정리한 문서로, 개발팀과 사용자 간의 공통된 이해를 제공하는 문서.
        - 소프트웨어 개발과 관련된 이해 당자에게 중요한 기준이 되는 문서.
    - 필요성:
        - 분석가와 사용자 간의 배경 지식에 차이가 있으므로 분석가가 현행 업무 내용을 파악 후 사용자와 대화할 수 있도록 준비해야 한다.
    - 작성 시 주의사항:
        - 사용자가 쉽게 읽고 이해할 수 있게 작성한다.
        - 개발자가 설계와 코딩에 효과적으로 사용할 수 있도록 작성한다.
        - 비기능적 요구를 명확히 작성한다.
        - 테스트 기준으로 사용할 수 있도록 정량적으로 작성한다.
        - 품질에 대한 우선순위를 명시한다.

### 요구사항 검증 및 관리

- **요구사항 검증**
    - 수집된 요구사항이 **정확하고 완전하며 일관성** 있는지 확인한다.
    - **방법**:
        - 요구사항 리뷰.
        - 프로토타입을 활용한 확인.
        - 사용자 피드백 수집.
- **요구사항 관리**
    - 프로젝트 진행 중 변경되는 요구사항을 체계적으로 관리한다.
    - **주요 활동**:
        - 요구사항 변경 요청 접수 및 평가.
        - 변경 사항의 추적 및 이력 관리.
        - 이해관계자와의 지속적인 소통.

# 소프트웨어 설계

### 소프트웨어 설계의 원칙

- 설계
    - 정의: 본격적인 프로그램 구현 이전에 소프트웨어를 구성하는 뼈대를 정의해 구현의 기반을 만드는 것.
    - 설계서: 요구사항 분석 명세서 기능이 실현되도록 알고리즘이나 해당 자료 구조를 문서화
    - 좋은 설계의 조건:
        - 설계서가 요구 분석 명세서의 내용을 모두 포함해야 한다.
        - 유지보수가 용이하도록 추적 가능해야 하고 변화에 쉽게 적응할 수 있어야 한다.
        - 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다.
        - 설계서는 읽기 쉽고 이해하기 쉽게 작성되어야 한다.
    - 구분
        - 관리적 관점
            - 기본 설계: 요구사항 분석 단계에서 생성된 정보를 자료 구조와 소프트웨어 구조로 변경
            - 상세 설계: 기본 설계 사항을 구체적인 자료 구조와 알고리즘으로 표현
        - 기술적 관점
            - 데이터 설계
            - 구조 설계
            - 절차 설계
        - 사용자적 관점:
            - 내부 설계
            - 외부 설계
    - 설계 프로세스
        - 정의: 설계에 대한 과정, 소프트웨어를 개발할 때 행하는 일련의 활동들
        - 일반적인 순서: 데이터 설계 → 아키텍처 설계 → 인터페이스 설계 → 절차 설계

### 모듈화, 추상화, 캡슐화

- 모듈화
    - 정의:
        - 규모가 큰 소프트웨어를 독립적인 조각으로 나누어 구조를 구성하는 기본 단위로 만드는 것이다.
        - 독립적인 프로그램, 함수 등이 하나의 모듈이 될 수 있다.
    - 특징:
        - 다른 것과 구별되는 **독립적인 기능**을 가진다.
        - **유일한 이름**을 가진다.
        - 모듈 간 호출이 가능하며, 다른 프로그램에서도 호출할 수 있다.
    - 원칙:
        - 모듈화 전에 **적절한 크기**로 나눌 계획이 필요하다.
        - 문제의 유형과 특성을 고려해야 한다.
        - 높은 응집도(high cohesion)와 낮은 결합도(loose coupling)를 유지한다.
    - 장점:
        - 소프트웨어 구조의 복잡도를 줄일 수 있다.
        - 기능 변경이 쉬우며, 변경에 따른 영향을 최소화할 수 있다.
        - 설계와 코드를 재사용 가능하다.
        - 문제를 이해하기 쉽게 만들고, 유지보수가 용이하다.
        - 오류로 인한 영향을 최소화할 수 있다.
- 추상화
    - **정의**:
        - 객체지향 설계에서 유사한 특성을 가진 것들을 그룹화한 후 **공통점을 추출**하여 이름을 붙이는 것이다.
    - **특징**:
        - 복잡한 시스템을 단순화하고 공통적인 특징에 집중할 수 있게 한다.
    - **종류**:
        - **과정 추상화**:
            - **정의**: 문제의 전체 흐름을 파악할 수 있는 알고리즘 형태로 작성.
            - **예시**: 학점 계산 시 과목 이름 없이 합계 및 평균 구하기.
        - **데이터 추상화**:
            - **정의**: 데이터와 구조를 감추고, 사용자에게 필요한 기능만 공개.
            - **예시**: 스택 자료구조.
        - **제어 추상화**:
            - **정의**: 제어 구조를 추상화하여 간결하게 표현.
            - **예시**: 기계 언어 → 어셈블리 언어 → 고급 언어로의 간소화.
    - **장점**:
        - 복잡한 시스템을 단순화하여 이해를 돕고, 유지보수와 재사용성을 높인다.
- 캡슐화
    - 정의:
        - 관련된 데이터와 처리 방식을 하나로 묶고, 외부에서는 **객체의 기능과 사용법만 제공**하며 내부는 감추는 것.
    - 특징:
        - 추상화를 통해 문제를 쉽게 개념화할 수 있다.
        - 객체 제공자와 이용자를 명확히 분리할 수 있다.
        - 객체 간 독립성이 보장된다.
        - 제공된 기능만 알면 사용이 가능해 모듈 이해가 쉽다.
        - 메서드 기능만 알면 객체를 쉽게 사용할 수 있다.
        - 내부 자료구조나 알고리즘 변경이 다른 객체에 영향을 미치지 않는다.
        - 새로운 기능 추가가 용이하다.
    - 장점:
        - **은닉성**을 통해 데이터 보안을 강화할 수 있다.
        - 변경에 따른 영향을 최소화하여 **유지보수성**을 높인다.
        - 객체 재사용성이 증가한다.

### 아키텍처 설계

- 아키텍처
    - **정의**:
        - 소프트웨어 시스템의 뼈대와 같은 **기본 구조**로, 시스템의 특성과 작동 방식을 결정한다.
    - **필요성**:
        - 복잡하거나 대규모 소프트웨어를 개발하려면 **구성요소 간의 유기적인 상호작용**이 필요하다.
        - 품질 좋은 소프트웨어 개발을 위해 **잘 정의된 구조**가 요구된다.
    - **특징**:
        - 소프트웨어의 **추상화된 전체 구조**를 제공한다.
        - 여러 구성요소와 이들 간의 상호작용을 다룬다.
        - **인터페이스**를 통해 구성요소 간의 상호작용을 정의한다.
        - 세부 내용보다는 **핵심 구조**와 **설계 원칙**에 집중한다.
    - **장점**:
        - 소프트웨어의 구조와 동작 방식을 예측할 수 있다.
        - 변경에 유연하게 대처할 수 있다.
        - 팀 간 **공통 이해**를 형성하고 구현상의 문제를 사전에 도출할 수 있다.
        - **설계 원칙과 가이드**를 제공하며 재사용 가능한 설계를 만들 수 있다.
        - 소프트웨어 아키텍처를 기준으로 **조직 구조**를 설계하거나 재편할 수 있다.
        - 품질 특성(성능, 보안 등)에 대한 평가 기준을 제공한다.
- 계층형 아키텍처
    - **정의**:
        - 소프트웨어의 기능을 **계층별로 분리**하여 배치하는 아키텍처 스타일이다.
    - **특징**:
        - 각 계층은 높은 **응집도**를 가지며, 계층 간 **결합도**는 낮다.
        - **유지보수성과 재사용성**이 높아 변경이 용이하다.
        - 계층 간 **역할 분담**이 명확하며, 독립적으로 수정 가능하다.
        - 대부분의 **운영체제**와 **통신 시스템**에서 사용된다.
    - **장점**:
        - 유지보수와 재사용성이 높다.
        - 계층 간 역할이 분리되어 구조 변경이 용이하다.
    - **단점**:
        - 계층 간 통신으로 성능 저하가 발생할 수 있다.
        - 불필요한 오버헤드가 생길 가능성이 있다.
- **MVC (Model-View-Controller) 스타일**
    - **정의**:
        - 구성요소를 **기능별로 분리**하여 유지보수와 확장성을 높이는 아키텍처 스타일이다.
    - **특징**:
        - **모델, 뷰, 제어**의 세 가지 구성 요소로 이루어져 있다.
        - 모델(View)과 뷰(Model)를 독립적으로 분리하여 **변경 영향**을 최소화한다.
        - 약한 결합(Loose Coupling)을 통해 구조 변경 시 **수정 용이성**을 제공한다.
    - **작동 과정**:
        1. 사용자가 **제어**에 데이터 요청 또는 입력을 전달한다.
        2. **제어**는 요청 처리를 위해 **모델**을 호출한다.
        3. **모델**은 데이터베이스(DBMS)를 통해 데이터를 수정하고 결과를 반환한다.
        4. **제어**는 결과를 가져와 **뷰**를 호출하고 사용자에게 전달한다.
        5. **뷰**는 결과를 테이블, 그래프 등 다양한 형태로 사용자에게 표시한다.
    - **장점**:
        - 변경에 유연하며 유지보수가 쉽다.
        - 각 구성요소의 역할이 명확해 코드 이해도가 높다.
    - **단점**:
        - 구조가 복잡해 설계와 구현이 어려울 수 있다.
- 마이크로서비스
    - **정의**:
        - 소프트웨어를 여러 개의 **작고 독립적인 서비스**로 나누어 개발하는 아키텍처 스타일이다.
        - 각 서비스는 특정 비즈니스 기능을 담당하며 독립적으로 배포, 개발, 운영이 가능하다.
    - **특징**:
        - 서비스 간 결합도가 낮아 **유연성과 확장성**이 높다.
        - 개별 서비스는 **API**를 통해 통신하며, 독립적으로 스케일링 가능하다.
        - 장애가 발생해도 다른 서비스에 영향을 최소화한다.
    - **장점**:
        - **유지보수와 확장**이 용이하다.
        - 독립적인 서비스로 장애 발생 시 영향이 제한적이다.
    - **단점**:
        - 서비스 간 통신을 위한 **복잡한 관리**가 필요하다.
        - 서비스가 많아질수록 운영 및 배포 관리가 어려워질 수 있다.

### 설계 패턴

- 생성 패턴
    - **정의**:
        - 객체 생성과 관련된 문제를 해결하기 위한 패턴으로, 객체 생성의 **캡슐화**와 **효율성**을 높인다.
    - **주요 패턴**:
        1. **팩토리 메서드 (Factory Method)**:
            - 객체 생성 방식을 서브클래스에서 정의하여 객체 생성의 유연성을 제공한다.
        2. **추상 팩토리 (Abstract Factory)**:
            - 관련 객체 그룹을 생성할 수 있는 인터페이스 제공한다.
        3. **빌더 (Builder)**:
            - 복잡한 객체 생성을 단계적으로 진행하며 객체 구성 방식을 분리한다.
        4. **프로토타입 (Prototype)**:
            - 객체를 복제하여 새로운 객체를 생성한다.
        5. **싱글톤 (Singleton)**:
            - 특정 클래스의 객체가 단 하나만 생성되도록 보장한다.
- 구조 패턴
    - **정의**:
        - 클래스 및 객체의 구조를 정의하여 시스템 구성 요소 간 관계를 **효율적으로 설계**.
    - **주요 패턴**:
        1. **어댑터 (Adapter)**:
            - 호환되지 않는 인터페이스를 연결하여 호환성 제공한다.
        2. **브리지 (Bridge)**:
            - 추상화와 구현을 분리하여 독립적으로 확장 가능하도록 설계한다.
        3. **컴포지트 (Composite)**:
            - 객체를 트리 구조로 구성하여 객체 간 계층 구조를 표현한다.
        4. **데코레이터 (Decorator)**:
            - 기존 객체에 새로운 기능을 동적으로 추가한다.
        5. **퍼사드 (Facade)**:
            - 복잡한 시스템의 기능을 단순화하여 클라이언트가 쉽게 접근하도록 제공한다.
        6. **플라이웨이트 (Flyweight)**:
            - 메모리 절약을 위해 동일한 데이터를 공유한다.
        7. **프록시 (Proxy)**:
            - 실제 객체에 대한 접근을 제어하기 위해 대리 객체를 사용한다.
- 행위 패턴
    - **정의**:
        - 객체 간의 상호작용과 책임 분배를 정의하여 **동작 방식을 효율적으로 설계**.
    - **주요 패턴**:
        1. **책임 연쇄 (Chain of Responsibility)**:
            - 요청을 처리할 객체를 체인 형태로 연결하여 유연하게 요청을 처리한다.
        2. **커맨드 (Command)**:
            - 요청을 객체로 캡슐화하여 요청의 실행, 취소, 저장이 가능하다.
        3. **반복자 (Iterator)**:
            - 객체 집합을 순차적으로 탐색할 수 있는 방법 제공.
            - **예시**: 리스트나 배열의 항목 순회.
        4. **중재자 (Mediator)**:
            - 객체 간의 복잡한 상호작용을 중재자 객체가 관리한다.
        5. **옵서버 (Observer)**:
            - 객체 상태 변화를 관찰하고, 관련 객체에 알린다.
            - **예시**: 뉴스 구독 시스템.
        6. **상태 (State)**:
            - 객체의 상태에 따라 행동이 달라지도록 설계한다.
        7. **전략 (Strategy)**:
            - 실행 중 교체 가능한 알고리즘을 정의한다.
        8. **템플릿 메서드 (Template Method)**:
            - 알고리즘의 골격을 정의하고 세부 구현은 서브클래스에서 제공한다.

### UML(Unified Modeling Language)

- **Unified Modeling Language(UML)**
    - 정의:
        - **시스템 개발을 위한 시각적 설계 표기법**으로, 객체 지향 시스템의 **명세화, 시각화, 문서화**에 사용된다.
        - 개발 시스템을 이해하기 쉬운 형태로 표현하여 **분석가, 설계자, 의뢰인 간의 효율적인 의사소통**을 돕는다.
        - **12개의 다이어그램**을 통해 시스템의 상호작용, 구조, 컴포넌트 간 관계 등을 시각화한다.
    - 특징:
        1. **시각화 (Visualization) 언어**
            - 소프트웨어의 개념 모델을 **시각적 다이어그램**으로 표현한다.
            - 표준화된 기호를 사용하여 **명확한 의사소통**이 가능하다.
        2. **명세화 (Specification) 언어**
            - 소프트웨어 개발의 **분석 및 설계 과정**에서 필요한 모델을 정확하게 정의한다.
            - 각 다이어그램은 **추상적이면서 고유한 의미**를 담고 있다.
        3. **구축 (Construction) 언어**
            - UML 모델을 **Java, C++, C#** 같은 프로그래밍 언어로 변환 가능하다.
            - UML 모델을 코드로 자동 변환하거나, 역공학(Reverse Engineering)을 통해 소스 코드를 UML로 변환하여 분석할 수 있다.
        4. **문서화 (Documentation) 언어**
            - StarUML, Together 등의 **CASE 툴**을 이용해 UML 설계 내용을 자동으로 문서화할 수 있다.
- 클래스 다이어그램
    - 정의: 시스템의 **구조적 설계**를 표현하는 다이어그램으로, 클래스 간의 관계를 모델링한다.
    - 필요성:
        - 시스템의 **데이터 구조와 설계**를 시각적으로 표현하여 이해를 돕는다.
        - 클래스 간의 상호작용을 명확히 정의하여 **개발 과정의 오류를 줄인다**.
    - 특징:
        - 객체지향 설계의 기본 요소인 **클래스, 속성, 메서드, 관계**를 정의한다.
        - 시스템의 정적 구조를 보여준다.
        - 클래스 간의 **연관, 상속, 집합, 의존성** 등을 표현한다.
    - 구성요소:
        - **클래스(Class)**:
            - 데이터(속성)와 메서드를 묶어 놓은 것
            - 직사각형 모양으로 세 칸으로 분리된다.
                - 첫번째 칸: 이름
                - 두번째 칸: 속성
                - 세번째 칸: 메서드
            
            ![스크린샷 2025-01-09 오후 10.35.56.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.35.56.png)
            
        - **클래스 이름:**
            - 클래스는 다른 클래스와 구분되는 유일한 이름을 가진다.
        - **속성**:
            - 클래스가 갖는 정적인 특성
            - 속성 이름은 소문자로 나타내며 두 단어 사용 시 두번째 단어의 첫 글자는 대문자로 쓴다.
        - **메서드**:
            - 클래스가 외부인 다른 객체에게 제공할 서비스와 기능
            - 외부 클래스는 메서드를 통해 해당 클래스에 접근할 수 있다.
            - 외부에서 이 기능을 요구하는지에 따라 메서드로 도출할 지 판단한다.
        - **가시성**
            - 속성과 메서드의 접근 권한을 지정하는 방식
            - 공개: `+`(public)
                - 같은 시스템에 있는 모든 클래스에 접근 가능.
            - 은닉: (private)
                - 같은 시스템 내의 다른 클래스는 직접 접근할 수 없고, 해당 클래스에서 제공하는 메서드를 통해서만 접근 가능.
            - 부분 공개: `#`(protected)
                - 다른 클래스가 접근할 수 없고 해당 클래스의 메서드와 클래스를 상속받은 하위 클래스만 접근 가능.
            - 패키지:  `~`(default)를 사용한다.
                - 동일 패키지에서만 클래스에 접근 가능.
            - `{}`는 **final**, 밑줄은 **static**을 나타낸다.
        - **스테레오타입 (Stereotype)**:
            - **<< >>** 기호를 사용해 **추상 클래스, 인터페이스, 열거형(enum)** 등을 표시한다.
            - 예: `<<interface>>`, `<<abstract>>`.
        - 다중성 표시:
            
            ![스크린샷 2025-01-09 오후 10.40.44.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.40.44.png)
            
        - **관계(Relationships)**: 클래스 간의 상호작용을 나타낸다.
            
            ![스크린샷 2025-01-09 오후 9.57.26.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.57.26.png)
            
            - **연관(Association) 관계**:
                - 클래스 간 **일반적인 연결 관계**를 나타낸다.
                - 예: 학생이 수업을 듣는다(Student - Course).
            - **일반화(Inheritance) 관계**:
                - 부모-자식 관계를 나타내며, **상속**을 통해 자식 클래스가 부모 클래스의 속성과 메서드를 물려받는다.
                - 예: 동물이 포유류를 상속한다(Animal -> Mammal).
            - **집합(Aggregation)**:
                - **"부분-전체" 관계**를 나타내며, 부분이 독립적으로 존재할 수 있다.
                - 예: 도서관과 책(Library - Book).
            - **합성(Composition) 관계**:
                - **"부분-전체" 관계** 중 더 강한 형태로, 전체가 소멸하면 부분도 함께 소멸한다.
                - 예: 사람과 심장(Person - Heart).
                - **의존(Dependency) 관계**:
                - 클래스 간의 **약한 종속성**을 나타내며, 한 클래스가 다른 클래스의 변화에 영향을 받는다.
                - 예: 주문이 결제 클래스를 참조(Order -> Payment).
- 시퀀스 다이어그램
    - 정의:
        - 객체 간 동적 상호작용을 시간 개념을 중심으로 모델링하는 다이어그램.
    - 필요성:
        - 객체 간의 메시지 전달 과정을 명확히 표현하여 **시스템 동작을 이해**할 수 있다.
        - **시간 축**을 중심으로 기능의 순서와 흐름을 분석한다.
    - 특징:
        - 방향은 시간의 흐름을 나타낸다.
        - 객체 간의 **기능, 순서, 시간**을 명확히 표현한다.
    - 구성 요소:
        - 객체: 메시지를 송수신하는 객체
        - 메시지: 객체 간 연결 기능을 담당
            - 호출 메시지, 답신 메시지, 비동기 메시지
        - 회귀 메시지: 같은 객체에 대한 함수(메서드)를 호출한다.
        - 제어 블록: 제어문을 위한 루프이다.
        - 답신 메시지: 이전 호출의 반환을 기다리는 객체에 다시 반환되는 메시지이다.
    - 예시:
        - 엘리베이터 사용 시나리오:
            - 객체: 사용자, 조작 시스템, 엘리베이터
            1. 사용자가 엘리베이터 버튼을 누름
            2. 엘리베이터가 위로 올라가거나 아래로 내려감
            3. 엘리베이터가 도착하면 문이 열림,
            일정 시간이 지나면 문이 닫힘
- 유스케이스 다이어그램
    - 정의:
        - 시스템이 제공하는 기능을 사용자 관점에서 표현한 다이어그램
    - 필요성:
        - 시스템의 기능을 사용자 중심으로 분석하여 **요구사항을 명확히 정의**할 수 있다.
        - 이해관계자 간의 **의사소통 도구**로 활용된다.
    - 특징:
        - 시스템의 **외부 행위**를 중심으로 표현한다.
        - 액터와 유스케이스 간의 관계를 통해 **시스템의 기능적 요구사항**을 명확히 한다.
    - 구성 요소:
        - **유스케이스(Use Case)**: 시스템의 기능 단위를 나타낸다.
        - **액터(Actor)**: 시스템과 상호작용하는 사용자 또는 외부 시스템.
        - **유스케이스 관계**:
            - **연관 관계**: 액터와 유스케이스 간의 상호작용.
            - **포함 관계**: 하나의 유스케이스가 다른 유스케이스를 포함.
            - **확장 관계**: 선택적으로 추가되는 기능.
            - **일반화 관계**: 유스케이스나 액터 간의 계층 관계.
        - 단계별 모델링 :
            1. **시스템 상황 분석**: 요구사항 문서화.
            2. **액터 식별**: 시스템과 상호작용하는 사용자 정의.
            3. **유스케이스 식별**: 액터 관점에서 시스템 기능 확인.
            4. **유스케이스 다이어그램 작성**: 액터와 유스케이스의 관계를 설정.
            5. **유스케이스 명세서 작성**: 각 유스케이스의 세부 사항 기술.
            6. **유스케이스 실체화**: 상세 설계로 발전.

# 소프트웨어 구현

### 프로그래밍 원칙과 관례

- **객체지향 5원칙 (SOLID)**
    1. **단일 책임 원칙 (SRP)**
        - 클래스는 하나의 책임만 가져야 하며, 하나의 이유로만 변경되어야 한다.
    2. **개방 폐쇄 원칙 (OCP)**
        - 클래스는 **확장**에는 열려 있고, **수정**에는 닫혀 있어야 한다.
    3. **리스코프 교체 원칙 (LSP)**
        - 자식 클래스는 부모 클래스를 대체해도 동작에 문제가 없어야 한다.
    4. **인터페이스 분리 원칙 (ISP)**
        - 클라이언트는 자신이 사용하는 기능에만 의존해야 하며, 불필요한 인터페이스는 분리해야 한다.
    5. **의존 관계 역전 원칙 (DIP)**
        - 고수준 모듈은 저수준 모듈에 의존하지 않고, 추상화에 의존해야 한다.
- **코딩 관례**:
    - **의미 있는 이름 사용**: 변수, 함수, 클래스 이름은 명확하고 직관적으로 작성한다.
    - **일관된 스타일**: 팀에서 정한 코드 스타일 가이드(Google Style Guide 등)를 따른다.
    - **적절한 주석**: 왜 이 코드가 필요한지 설명하며, 불필요한 주석은 피한다.
    - **포맷팅**: 들여쓰기, 줄 간격 등 가독성을 높이는 일관된 코드 구조를 유지한다

### 코드 품질 관리

- **가독성**:
    - 코드를 쉽게 읽고 이해할 수 있도록 변수 이름, 함수 길이, 코드 포맷에 신경 쓴다.
    - 함수는 한 가지 역할만 하도록 작성하며, 코드 블록을 잘 구분한다.
- **유지보수성**:
    - 변경이 쉽고 기존 기능에 영향을 최소화할 수 있도록 코드를 작성한다.
    - 모듈화와 캡슐화를 활용하여 코드 구조를 단순화한다.
- **재사용성**:
    - 중복 코드를 줄이고 공통 기능은 별도의 모듈이나 라이브러리로 분리한다.
    - 유연한 설계를 통해 다양한 상황에서 재사용 가능하도록 한다.

### 버전 관리 시스템

- **Git**:
    - 분산형 버전 관리 시스템으로, 코드 변경 이력을 관리하고 팀 협업을 지원한다.
- **GitHub**:
    - Git을 기반으로 한 웹 플랫폼으로, 버전 관리와 협업을 지원한다.
    - **Pull Request(PR)**: 코드 변경 내용을 리뷰받고 병합할 때 사용.
    - **Issues**: 버그, 기능 요청 등을 관리하는 도구.
    - **Actions**: CI/CD 자동화 도구.

### 코드 리뷰와 협업 도구

- 동료 개발자가 코드를 검토하며, 코드 품질 향상과 버그 발견에 기여한다.
- **좋은 코드 리뷰 관행**:
    - 코드의 가독성, 유지보수성, 재사용성을 확인한다.
    - 단순한 문법 오류보다는 설계와 로직에 초점을 맞춘다.
    - 건설적인 피드백을 제공한다.
- **협업 도구**:
    - **Jira**: 작업 관리와 애자일 개발 지원.
    - **Slack**: 팀 간 실시간 커뮤니케이션 도구.
    - **Confluence**: 프로젝트 문서화 및 협업 플랫폼.
    - **Figma**: UI/UX 설계 협업 도구.

# 소프트웨어 테스트

### 소프트웨어 테스트의 필요성과 목적

- **정의**:
    - 시스템이 명시된 요구를 잘 만족하는지 확인하기 위해 **수동** 또는 **자동화된 방식**으로 검사하고 평가하는 작업.
    - 테스트는 예상된 결과와 실제 결과의 차이를 확인하여 시스템의 품질을 보장한다.
    - **특징**:
        - 테스트는 결함이 있음을 확인할 수 있지만, **결함이 없음을 증명할 수는 없다**.
        - 테스트 시스템 자체가 완벽하다고 증명할 수 없으므로 프로그램을 완전히 테스트하는 것은 불가능하다.
- **목적**:
    - 고객의 요구사항을 충족시키기 위한 필수 과정이다.
    - 단순히 테스트 단계에서만 수행되는 작업이 아니라, **개발 단계와 병행**하여 진행해야 한다.
    - **파레토 원리**:
        - 전체 결함의 80%는 20%의 모듈에서 발생한다는 원칙을 적용하여 효율적인 테스트를 수행.
    - 점진적으로 **모듈 단위를 확대**하며 결함을 찾아 수정한다.
    - **별도의 독립적인 테스트 팀**에서 수행하여 객관성을 확보한다.
    - 테스트 내성을 해결하기 위해 **테스트 케이스를 지속적으로 업데이트**해야 한다.
- 절차:
    - 테스트 계획 → 테스트 케이스 설계 → 테스트 실행 및 측정 → 테스트 결과 분석 → 오류 추적 및 수정

### 테스트 수준

- V 모델: 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트, 회귀 테스트

![스크린샷 2025-01-09 오후 11.13.44.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.13.44.png)

- 단위 테스트
    - **정의**:
        - 소프트웨어의 기본 단위인 모듈을 테스트하여 요구사항에 맞게 구현되었는지 확인하는 테스트.
    - **특징**:
        - 구현 단계에서 각 모듈이 정해진 기능을 정확히 수행하는지 테스트한다.
        - 상위 모듈과 하위 모듈을 가상으로 대체하기 위해 **드라이버**와 **스텁**을 사용한다.
            
            ![스크린샷 2025-01-09 오후 11.09.51.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%201765752e2f2380658fb1dc2282712a93/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-09_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.09.51.png)
            
            - 드라이버: 상위 모듈 역할을 하는 가상의 모듈
            - 스텁: 하위 모듈 역할을 하는 가상의 모듈
    - **발견 가능한 오류**:
        - 잘못된 자료형, 논리 연산 오류, 알고리즘 문제, 계산 수식 오류, 무한 루프 등.
- 통합 테스트
    - **정의**:
        - 단위 테스트가 끝난 모듈 간의 상호작용을 테스트하여 통합 과정에서 발생할 수 있는 오류를 확인하는 테스트.
    - **모듈 통합 방법**:
        1. **Big-bang 테스트**:
            - 단위 테스트가 완료된 모든 모듈을 한 번에 통합하여 테스트.
            - 단점: 오류 발생 시 원인 추적이 어렵다.
        2. **하향식 기법**:
            - 최상위 모듈부터 점차 하위 모듈로 통합.
            - 스텁이 필요하며, 계층 구조를 유지하면서 통합 가능하다.
        3. **상향식 기법**:
            - 최하위 모듈부터 상위 모듈로 통합.
            - 테스트 드라이버가 필요하며, 하위 모듈의 철저한 테스트가 가능하다.
- 시스템 테스트
    - **정의**:
        - 소프트웨어 시스템 전체가 정상적으로 작동하며 요구사항을 충족하는지 확인하는 테스트.
        - 사용자에게 전달되기 전에 실제 환경과 유사한 조건에서 수행한다.
    - **특징**:
        - 기능적 요구사항과 비기능적 요구사항을 모두 검증한다.
        - 부하 테스트를 포함하여 소프트웨어의 안정성과 성능 확인한다.
- 인수 테스트
    - **정의**:
        - 소프트웨어가 요구사항에 맞게 작동하는지 사용자 입장에서 확인하는 테스트.
        - 테스트가 완료되면 사용자 인수 승낙과 함께 프로젝트가 종료.
    - **종류**:
        1. **알파 테스트**:
            - 내부 환경에서 수행, 개발자가 문제를 직접 관찰.
        2. **베타 테스트**:
            - 특정 사용자들에게 배포하여 실제 사용 환경에서 피드백을 받는 테스트.

- 회귀 테스트
    - **정의**:
        - 코드 수정 후 새로운 문제가 발생하지 않았는지 확인하는 테스트.
    - **유형**:
        1. **확정 테스트**:
            - 수정된 부분이 올바르게 동작하는지 검증한다.
        2. **수정을 위한 회귀 테스트**:
            - 발견되지 않은 오류를 수정 후 전체 테스트를 재실행한다.
        3. **점진적 회귀 테스트**:
            - 새로운 기능 추가 후 소프트웨어 전체를 다시 테스트한다.

### 테스트 기법

- **화이트박스 테스트**
    - **정의**:
        - 프로그램의 내부 구조와 로직을 기반으로 테스트 케이스를 설계하는 기법.
        - 프로그램 코드의 제어 흐름, 변수, 서브루틴 등을 검토하여 오류를 찾는다.
    - **특징**:
        - 코드를 실행하지 않고도 테스트 케이스를 생성 가능하다.
        - **제어흐름 그래프**를 작성하여 코드의 흐름을 시각적으로 분석한다.
    - **커버리지 유형**:
        1. **문장 커버리지**:
            - 모든 문장을 최소한 한 번 실행하도록 설계한다.
        2. **분기 커버리지**:
            - 모든 조건의 분기(참/거짓)를 한 번씩 실행한다.
        3. **데이터흐름 커버리지**:
            - 변수의 선언과 사용 경로를 모두 커버한다.
        4. **조건 커버리지**:
            - 조건문에 대해 모든 가능한 결과(참/거짓)를 포함한다.
        5. **다수 조건 분기 커버리지 (MC/DC)**:
            - 조건 커버리지와 분기 커버리지를 동시에 만족시키며, 각 조건식이 결과에 미치는 영향을 검증한다.
- **블랙박스 테스트**
    - **정의**:
        - 프로그램 내부의 구조나 로직을 보지 않고, 요구사항과 설계 명세서를 기반으로 테스트 케이스를 설계하는 기법.
        - 입력 값에 따른 예상 출력 값이 정확한지 확인한다.
    - **특징**:
        - 소프트웨어의 **기능적 요구사항**을 검증하며, 내부 구현은 고려하지 않는다.
        - 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 등 모든 단계에 적용 가능하다.
    - **테스트 기법**:
        1. **문법(Syntax) 기법**:
            - 문법적으로 적합하거나 부적합한 입력 값을 테스트한다.
        2. **동치 분할 기법**:
            - 입력값을 여러 영역으로 나누어 각 영역에서 하나의 값을 테스트한다.
        3. **경계 값 분석 기법**:
            - 경계에 위치한 값 및 경계 이전/이후 값을 테스트한다.
        4. **원인-결과 그래프 기법**:
            - 입력 조건(원인)과 결과를 그래프로 표현하고, 의사결정 테이블을 통해 테스트 케이스를 생성한다.

### 테스트 자동화 도구

- **Selenium**
    - **정의**:
        - 웹 애플리케이션의 **UI 테스트**를 자동화하는 오픈소스 도구.
    - **특징**:
        - 다양한 브라우저와 호환 가능하다.
        - 스크립트를 작성하여 사용자 인터페이스 동작을 시뮬레이션한다.
        - 테스트 케이스를 다양한 프로그래밍 언어(Java, Python, C# 등)로 작성 가능하다.
    - **장점**:
        - 반복적인 브라우저 테스트 자동화.
        - 크로스 브라우저 및 플랫폼 테스트 지원.
    - **활용 예시**:
        - 로그인, 폼 제출, 페이지 탐색과 같은 웹 애플리케이션 동작 테스트.
- **JUnit**
    - **정의**:
        - Java 애플리케이션의 **단위 테스트**를 위한 프레임워크.
    - **특징**:
        - 테스트 케이스 작성 및 실행을 지원한다.
        - 어노테이션을 활용해 간결한 코드를 작성할 수 있다.
        - 반복 가능한 테스트와 결과 리포트를 제공한다.
    - **장점**:
        - Java 프로젝트에서 단위 테스트 표준으로 사용한다.
        - 지속적 통합(CI) 환경에서 테스트 자동화가 가능하다.
    - **활용 예시**:
        - 메서드의 입력값과 출력값 검증.
- **PyTest**
    - **정의**:
        - Python 애플리케이션의 **단위 테스트와 통합 테스트**를 지원하는 프레임워크.
    - **특징**:
        - 간단하고 가독성이 높은 테스트 케이스를 작성할 수 있다.
        - 플러그인 시스템으로 확장성 제공한다.
        - 다양한 테스트 요구 사항에 맞춘 풍부한 기능을 제공한다.
    - **장점**:
        - Python 프로젝트에 최적화되어 사용이 간편하다.
        - 테스트 코드를 간결하고 직관적으로 작성 가능하다.
    - **활용 예시**:
        - 웹 API의 요청/응답 테스트.

# 소프트웨어 유지보수

### 유지보수의 정의와 유형

- **정의**:
    - 소프트웨어가 개발된 후, 환경 변화나 비즈니스 요구사항을 반영하기 위해 수행하는 수정 작업.
    - 소프트웨어가 유용한 상태를 유지하며, 진화와 개선을 거듭할 수 있도록 지원.
- **유형**:
    1. **수정형 유지보수 (Corrective Maintenance)**
        - 발견된 결함을 수정하여 오류를 제거한다.
    2. **적응형 유지보수 (Adaptive Maintenance)**
        - 변경된 환경에서도 소프트웨어가 정상 작동하도록 변경한다.
    3. **완전형 유지보수 (Perfective Maintenance)**
        - 성능 및 유지보수성을 개선하기 위한 변경 작업이다.
    4. **예방형 유지보수 (Preventive Maintenance)**
        - 미래에 발생할 수 있는 오류를 방지하기 위한 작업이다.

### 유지보수 프로세스

- **유지보수 과정**:
    1. **현재 프로그램 이해**:
        - 프로그램 로직과 요구사항을 분석하여 변경의 영향을 파악한다.
    2. **변경 파악과 분석**:
        - 필요한 변경 사항을 확인하고 리스크와 비용을 평가한다.
    3. **변경 영향 파악**:
        - 이해 관계자와 협의하고 피드백을 수집한다.
    4. **변경 구현, 테스트, 설치**:
        - 변경을 적용하고 검증 후 시스템에 반영한다.
- 유지보수 프로세스 모델:
    - **즉시 수정 모델**: 빠른 변경과 배포를 목표로 한다.
    - **반복적 개선 모델**: 점진적으로 개선하며 안정성을 높인다.
    - **재사용 중심 모델**: 기존 구성요소를 재활용하여 유지보수 비용을 절감한다.

### 리팩토링과 코드 품질 개선

- 리팩토링
    - **정의**:
        - 소프트웨어의 **외부 동작은 유지**하면서 **내부 구조를 개선**하여 코드 품질을 향상시키는 작업.
        - 기능이나 설계의 변경 없이 가독성과 유지보수성을 높인다.
    - **목적**:
        - 코드 가독성, 유지보수성, 성능 개선.
        - 코드 중복 제거, 모듈화, 구조 간소화.
    - **사용 사례**:
        - 복잡한 코드를 단순화하여 향후 유지보수를 용이하게 한다.
        - 새로운 기능 추가 전에 코드 품질을 개선한다.
- **소프트웨어 품질**
    - **정의**:
        - 소프트웨어가 사용자의 기대와 요구사항을 얼마나 충족하는지를 나타내는 정도.
        - 프로그램의 결함 유무, 요구사항 만족 여부, 사용 편의성이 품질의 주요 기준이 된다.
    - **품질 요소**:
        - **외적 품질 요소**
            - **정확성 (Correctness)**: 주어진 명세서대로 정확히 동작하는지 테스트로 판단.
            - **신뢰성 (Reliability)**: 소프트웨어가 고장 없이 안정적으로 동작하는 정도.
            - **견고성 (Robustness)**: 예상하지 못한 입력이나 환경에서도 소프트웨어가 안정적으로 동작하는 능력.
            - **성능 (Performance)**: 메모리 사용량, 실행 속도 등 효율성을 나타냄.
            - **사용자 친숙성 (User Friendliness)**: 소프트웨어가 사용하기 쉽고 직관적인지 평가.
            - **가용성 (Availability)**: 소프트웨어가 사용자에게 사용 가능한 시간의 비율.
            - **보안성 (Security)**: 외부 위협으로부터 소프트웨어를 보호하는 능력.
        - **내적 품질 요소**
            - **검증 가능성 (Verifiability)**: 소프트웨어 속성을 정확히 확인할 수 있는지 평가.
            - **유지보수성 (Maintainability)**: 소프트웨어가 오류 수정, 환경 적응, 성능 개선이 얼마나 쉬운지 판단.
            - **재사용성 (Reusability)**: 기존 소프트웨어 구성요소를 다른 프로젝트에서 재사용할 수 있는 정도.
            - **이식성 (Portability)**: 다양한 하드웨어 및 소프트웨어 플랫폼에서 동작할 수 있는 능력.
            - **생산성 (Productivity)**: 단위 시간당 얼마나 효율적으로 개발과 유지보수가 이루어지는지 측정.
            - **상호 운용성 (Interoperability)**: 다른 소프트웨어와 협력하여 동작할 수 있는 능력.
    - 소프트웨어 품질 관리 프로세스:
        1. **준비 단계**: 품질 관리 계획 수립, 표준과 도구 설정.
        2. **척도 조정 단계**: 프로젝트의 품질 요소를 정하고 측정 기준 확립.
        3. **측정 단계**: 데이터를 수집하고 정량적으로 분석.
        4. **평가 단계:** 수집된 데이터로 품질 수준을 평가하고 개선점 도출.
        5. **관리 단계**: 조직 차원에서 품질 관리 활동을 지속적으로 개선.

# 프로젝트 관리

### 소프트웨어 프로젝트 관리 개념

- 정의:
    - 소프트웨어 개발 프로젝트를 체계적으로 계획, 실행, 통제하여 **목표, 일정, 자원, 품질**을 달성하는 활동.
- 특징:
    - 문제 정의와 타당성 분석(경제적, 기술적, 법적 타당성)을 통해 프로젝트의 실현 가능성을 검토한다.
    - 프로젝트 팀을 중앙집중형, 분산형, 하이브리드형 등 구조에 맞게 구성한다.

### 프로젝트 계획과 일정 관리

- **작업 분할 구조(WBS)**: 프로젝트를 세부 작업 단위로 나누어 구조화한다.
- **일정 계획 방법**:
    - **간트 차트**: 작업 일정과 진행 상황을 시각적으로 표현한다.
    - **네트워크 차트(PERT/CPM)**: 작업 간의 관계와 크리티컬 경로를 파악한다.

### 자원 관리

- **인력**: 팀 구성원 간 역할과 책임을 명확히 정의하고, 적절한 기술과 경험을 가진 인력을 배치한다.
- **비용**:
    - **하향식 산정 기법**: 전문가 판단, 델파이 기법.
    - **상향식 산정 기법**: 원시 코드 라인 수 기법, 개발 단계별 노력 기법.
    - **수학적 산정 기법**: COCOMO 모델, 기능 점수 모델.
- **도구**: 프로젝트 관리 도구(Jira, Trello), 버전 관리 도구(Git), 빌드 및 테스트 도구(Jenkins)

### 리스크 관리

- 정의: 프로젝트 추진 중 발생 가능한 위험 요소를 사전에 식별하고 대책을 마련하는 활동이다.
- **리스크 관리 단계**:
    1. **리스크 식별**: 예상 가능한 위험 요소 도출.
    2. **리스크 평가**: 발생 가능성과 영향 분석.
    3. **대응 계획 수립**: 회피, 완화, 수용 등의 전략 마련.
    4. **리스크 모니터링**: 지속적인 위험 관리 및 조정.

### 소프트웨어 품질 보증 (SQA)

- 정의: **소프트웨어 품질보증**(Software quality assurance, **SQA**)은 모든 소프트웨어 공학 프로세스, 방법 및 작업 결과물을 모니터링하여 정의된 표준을 준수하는지 확인하는 수단이자 관행이다.
- **목적:** 결함을 줄이고, 소프트웨어 품질과 사용자 신뢰를 확보하여 개발자 작업의 품질을 보장한다.
- **특징**:
    - 설계 검토, 코드 리뷰, 테스트(단위, 통합, 시스템 등)를 포함한다.
    - 소프트웨어 개발 전 과정에서 품질을 지속적으로 평가.
    - 개발 팀과 독립적으로 관리되며, 표준 준수 여부를 점검한다.
- 장점:
    - 요구사항에 맞는 품질 높은 소프트웨어를 제공하여 **신뢰성과 사용자 만족도**를 보장한다.
    - 결함을 조기에 발견하고 수정하여 **개발 시간과 비용을 절감**할 수 있다.

# 애자일 소프트웨어 개발

### 애자일의 원칙과 가치

- **애자일의 4가지 핵심 가치**
    1. **개인과 상호작용** > **프로세스와 도구**
        - 성공적인 프로젝트는 사람과의 소통과 협업에 의해 이루어진다.
    2. **작동하는 소프트웨어** > **포괄적인 문서화**
        - 상세한 문서화보다 작동 가능한 소프트웨어를 제공하는 것이 우선이다.
    3. **고객과의 협력** > **계약 협상**
        - 고객과의 지속적인 소통과 협력으로 요구사항을 명확히 하고 변화를 수용한다.
    4. **변화에 대한 민첩한 대응** > **계획을 따르기**
        - 계획이 아닌 환경 변화와 요구사항 변화에 유연하게 대처한다.
- **애자일의 12가지 원칙**
    1. **고객 만족을 최우선**으로 한다.
    2. **요구사항의 변화를 환영**한다.
    3. **짧은 주기로 작동 가능한 소프트웨어를 자주 제공**한다.
    4. **비즈니스 인사와 개발자는 프로젝트 내내 매일 협력**한다.
    5. **동기부여된 개인들을 중심으로 프로젝트를 구성**한다.
    6. **정보 전달의 가장 효과적인 방법은 대면 대화**이다.
    7. **작동하는 소프트웨어는 진척의 주요 척도**이다.
    8. **애자일 프로세스는 지속 가능한 개발을 촉진**한다.
    9. **기술적 탁월성과 좋은 디자인에 지속적으로 주의를 기울인다.**
    10. **간결함(심플함)을 중요시**한다.
    11. **최고의 설계와 요구사항은 자율적인 팀에서 나온다.**
    12. **팀은 정기적으로 더 효과적인 방법을 반성**한다.

### 스크럼 프레임워크

- 스크럼:
    - 정의:
        - 애자일 방법론의 대표적인 프레임워크로, 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리에 중점을 둔 방법론.
    - **스프린트 (Sprint)**
        - **정의**:
            - 1~4주 동안 진행되는 **짧은 개발 주기**로, 특정 목표를 달성하기 위해 계획된 작업을 수행하는 시간 단위이다.
            - 스프린트가 끝날 때는 항상 완성된 결과물(작동 가능한 소프트웨어)이 산출된다.
        - **특징**:
            - 일정은 **고정적**이며, 스프린트 중에는 목표가 변경되지 않는다.
            - 매 스프린트 종료 후, **스프린트 리뷰**와 **스프린트 회고**를 통해 개선점을 찾는다.
        - **목적**:
            - 짧은 반복 주기를 통해 고객 피드백을 신속히 반영하고, 개발 리스크를 줄인다.
    - **백로그 (Backlog)**
        - **정의**:
            - 프로젝트에 필요한 모든 작업의 목록이다.
            - 제품 백로그(Product Backlog)와 스프린트 백로그(Sprint Backlog)로 나뉜다.
        - **제품 백로그(Product Backlog)**:
            - 제품의 요구사항과 기능을 **우선순위**에 따라 나열한 리스트이다.
            - *제품 책임자(Product Owner)**가 작성 및 관리하며, 지속적으로 업데이트된다.
        - **스프린트 백로그(Sprint Backlog)**:
            - 특정 스프린트에서 수행할 작업의 목록으로, **개발 팀**이 작성하고 관리한다.
            - 스프린트 기간 동안 달성 가능한 목표에 맞춰 작업을 선택한다.
        - **목적**:
            - 작업의 투명성과 우선순위를 제공하여, 팀이 명확한 목표를 가지고 개발에 집중하도록 한다.
    - **데일리 스탠드업 (Daily Stand-up)**
        - **정의**:
            - 매일 진행되는 짧은 미팅(15분 내외)으로, 팀원들이 현재 진행 상황을 공유하고 문제를 논의한다.
        - **구성 질문**:
            - **어제 무엇을 했는가?**
            - **오늘 무엇을 할 예정인가?**
            - **현재 작업에 장애물은 무엇인가?**
        - **특징**:
            - **서서 진행**하여 미팅 시간을 최소화하고 효율성을 높인다.
            - 팀원 간의 **투명한 커뮤니케이션**을 촉진한다.
        - **목적**:
            - 팀원들의 진행 상황을 공유하여 협업을 강화하고, 발생한 문제를 신속히 해결한다.
    - 장점:
        - 짧은 주기마다 고객 피드백을 반영하여 품질과 만족도를 높인다.
        - 팀원 간의 긴밀한 소통과 협력을 통해 효율적인 문제 해결이 가능하다.
    - 단점:
        - 스크럼 마스터의 역할이 중요하며, 경험 부족 시 프로젝트에 부정적 영향을 미칠 수 있다.
        - 스크럼 프로세스에 적응하려면 초기 학습과 경험이 필요하다.

### 칸반과 지속적 전달

- **정의**:
    - 작업의 **시각적 관리 도구**로, 작업의 흐름을 효율적으로 관리하기 위해 사용.
    - 칸반 보드를 통해 작업 상태(예: 할 일, 진행 중, 완료)를 시각화하여 투명성과 작업 효율성을 높인다.
- **특징**:
    - **작업 제한(WIP, Work In Progress)**: 동시에 진행하는 작업의 수를 제한하여 과부하를 방지한다.
    - **지속적인 개선**: 작업 흐름을 분석하고 병목 현상을 제거한다.
    - **유연성**: 작업의 순서를 수시로 변경 가능하다.
- **목적**:
    - 작업 과정을 투명하게 하고, 병목 현상을 줄이며, 효율성을 높이는 것이다.
- **활용 사례**:
    - 소프트웨어 개발, 제조업, 서비스 지원 등 다양한 분야에서 사용된다.
- 장점:
    - 작업 상태를 시각적으로 표현해 팀의 작업 흐름과 병목 현상을 쉽게 파악할 수 있다.
    - 작업 우선순위와 내용 변경이 자유롭고, 특정 계획에 얽매이지 않는다.
    - 과부하를 방지하고 생산성을 높인다.
- 단점:
    - 명확한 반복주기가 없어 진행 상황 추적이 어려울 수 있다.
    - 경험이 부족한 팀에서는 병목 제거와 작업 흐름 최적화가 까다로울 수 있다.

### XP(익스트림 프로그래밍)의 실천

- **정의**
    - 소프트웨어 개발을 효율적으로 수행하기 위한 **애자일 방법론**의 하나로, 고객과의 협력, 빠른 피드백, 단순한 설계 등을 강조한다.
- **XP의 주요 실천 항목**
    1. **테스트 기반 개발 (TDD)**:
        - 테스트를 먼저 작성하고, 이를 만족시키는 코드를 작성.
    2. **짝 프로그래밍 (Pair Programming)**:
        - 두 명의 개발자가 한 컴퓨터로 협력하여 코드를 작성.
        - 한 명은 코드를 작성하고, 다른 한 명은 이를 검토.
    3. **작은 릴리즈 (Small Releases)**:
        - 작고 빈번한 릴리즈로 피드백을 빠르게 수집.
    4. **계속적인 통합 (Continuous Integration)**:
        - 코드 변경 시마다 빌드와 테스트를 자동으로 수행하여 통합.
    5. **단순 설계 (Simple Design)**:
        - 현재 요구사항만 충족시키는 단순하고 명확한 설계를 지향.
    6. **리팩토링 (Refactoring)**:
        - 소프트웨어의 외부 동작은 유지하면서 코드를 정리하고 개선.
    7. **40시간 근무 (Sustainable Pace)**:
        - 개발자는 지속 가능한 속도로 일하며, 과도한 업무를 방지.
    8. **공유 코드 (Collective Code Ownership)**:
        - 팀의 모든 개발자가 코드를 자유롭게 수정 가능.
    9. **코드 표준 (Coding Standards)**:
        - 팀이 일관된 코드 스타일을 준수.
    10. **메타포 (Metaphor)**:
        - 시스템을 이해하기 쉽게 설명하는 공통 비유나 은유 사용.
- 장점:
    - 테스트 기반 개발과 지속적 통합을 통해 코드 품질과 신뢰성이 높다.
    - 고객의 요구를 신속하게 반영할 수 있다.
    - 팀원간의 협력이 촉진된다.
- 단점:
    - 초기 개발 비용과 시간이 많이 소요될 수 있다.
    - 고객이 지속적으로 참여하지 않으면 효과가 떨어질 수 있다.

# 소프트웨어 메트릭

### 소프트웨어 메트릭의 개념

- 소프트웨어 개발 프로젝트를 체계적으로 계획, 실행, 통제하여 **목표, 일정, 자원, 품질**을 달성하는 활동.
- 문제 정의와 타당성 분석(경제적, 기술적, 법적 타당성)을 통해 프로젝트의 실현 가능성을 검토.
- 프로젝트 팀을 중앙집중형, 분산형, 하이브리드형 등 구조에 맞게 구성.
- 사용 목적을 가지고 소프트웨어의 품질을 판단하는데 도움을 주는 지표

### 코드 복잡도 측정

- 사이클로매틱 복잡도
    - 
    
    **Cyclomatic Complexity 장단점**
    
    정량적 수치로 하나의 값을 제시하여 준다는 점에서 이해하기가 쉽다. 그리고 수치로 표현되기 때문에 비교가 쉬우며 설계단계에서 사용하기 가장 용이하다.
    
    그러나 단점으로는 코드의 복잡성을 파악하기 쉬우나 데이터의 복잡성을 파악하기 어려운 점이 있다. 뿐만 아니라 Switch case에서 사용시 복잡도가 기하급수적으로 늘어난다는 단점이 있다.
    
    **[출처]** [리팩토링: 순환복잡도 (Cyclomatic Complexity) 정의](https://blog.naver.com/dracon123/220315761168)|**작성자** [IT 칼럼리스트](https://blog.naver.com/dracon123)
    

### 생산성과 품질 메트릭

### 메트릭 기반 프로젝트 관리

# 리스크 관리

### 소프트웨어 개발에서 리스크 정의

- **정의:**
    - 프로젝트의 목표 달성을 방해할 수 있는 **잠재적 문제나 불확실성**.
    - 일정 지연, 예산 초과, 품질 저하 등을 초래할 수 있다.

### 리스크 식별과 평가

- **리스크 식별**:
    - 발생 가능한 모든 리스크 요소를 도출한다.
    - **기법**: 브레인스토밍, 체크리스트, 과거 프로젝트 분석.
- **리스크 평가**:
    - 각 리스크의 **발생 가능성**과 **영향**을 평가하여 우선순위를 결정한다.
    - **분석 방법**: 정성적 분석(전문가 판단), 정량적 분석(수치화된 데이터).

### 리스크 완화 및 대응 전략

- **회피(Avoidance)**: 리스크를 유발하는 활동을 변경하거나 제거.
- **완화(Mitigation)**: 리스크 발생 가능성이나 영향을 줄이는 조치.
- **전가(Transfer)**: 리스크를 외부 업체나 보험으로 이전.
- **수용(Acceptance)**: 리스크를 인지하고 그대로 진행하며 대응 계획 마련.

### 리스크 관리 도구

- **Jira, Trello**: 작업 추적과 리스크 관리.
- **RiskWatch**: 리스크 분석 및 평가 도구.
- **Microsoft Project**: 프로젝트 계획 및 리스크 관리 통합.

# 소프트웨어 재사용과 컴포넌트 기반 개발

### 소프트웨어 재사용의 개념과 이점

- **개념**:
    - 기존 소프트웨어 자산을 새로운 프로젝트에 활용하여 개발 효율성을 높이는 활동.
- **이점**:
    - 개발 비용 및 시간 절감할 수 있다.
    - 품질과 신뢰성 향상시킬 수 있다.
    - 중복 작업 감소로 생산성이 향상된다.

### 라이브러리와 프레임워크 활용

- **라이브러리**:
    - 정의: 특정 기능을 수행하는 코드 집합.
    - 용도: 개발자가 필요 시 호출하여 사용한다.
    - **예시**: JavaScript의 Lodash, Python의 NumPy.
- **프레임워크**:
    - 정의: 애플리케이션 개발의 구조와 기본 틀을 제공.
    - 용도: 개발자가 특정 규칙에 따라 코드를 작성하여 활용한다.
    - **예시**: Spring, Django, React.

### 컴포넌트 기반 개발 (CBD)

- 정의:
    - 독립적이고 재사용 가능한 소프트웨어 컴포넌트를 조합하여 시스템을 개발하는 것.
- 장점:
    - 유지보수와 확장성 용이하다.
    - 개발 시간이 단축되고 품질이 향상된다.

### API 설계와 통합

- **API(Application Programming Interface)**:
    - 정의:
        - 소프트웨어와 소프트웨어 간의 **통신 및 상호작용을 가능하게 하는 인터페이스**.
        - 애플리케이션이 외부 서비스나 내부 모듈과 **데이터와 기능을 교환**하도록 돕는 표준화된 방식.
    - **역할**:
        - 서로 다른 시스템을 연결한다.
        - 특정 기능이나 데이터를 제공받거나 활용한다.
    - **형태**:
        - **RESTful API**: HTTP를 기반으로 설계된 API로, URL과 HTTP 메서드를 사용하여 자원(Resource)을 관리.
        - **GraphQL**: 클라이언트가 필요한 데이터만 선택적으로 요청할 수 있는 쿼리 언어 기반 API.
        - **SOAP**: XML을 사용하여 데이터 교환을 수행하는 API 프로토콜.
    - API 설계 원칙:
        - **일관성과 간결성**:
            - 경로와 데이터 구조는 **일관성 있게 설계**하여 직관적이고 사용하기 쉽게 한다.
        - **명확한 요청 및 응답 설계**:
            - 요청과 응답 데이터는 **간결하면서도 충분한 정보를 포함**하도록 설계한다.
        - **문서화**:
            - API의 기능, 요청/응답 형식, 상태 코드 등을 상세히 기록하여 **개발자들이 쉽게 이해**할 수 있도록 지원한다.
        - **보안 고려**:
            - 인증(Authentication)과 권한(Authorization)을 설정한다.
            - 민감한 데이터는 암호화 처리한다.
    - API 통합:
        - **정의**:
            - API를 통해 **다양한 시스템, 서비스, 애플리케이션 간 데이터를 교환**하고 기능을 연결하는 과정.
        - **통합 과정**:
            - **API 요청(Request)**: 클라이언트가 API 서버에 데이터를 요청.
            - **응답(Response)**: 서버가 요청에 대한 결과를 클라이언트로 반환.
            - **데이터 처리**: 응답 데이터를 클라이언트에서 처리하여 화면에 표시하거나 추가 작업 수행.
        - **API 통합 사례**:
            - **결제 시스템 연동**:
                - 클라이언트가 결제 요청 → API를 통해 결제 서비스와 통신 → 결제 승인 결과 반환.
            - **소셜 로그인 기능**:
                - 클라이언트가 Facebook, Google 등의 소셜 계정을 통해 로그인 요청 → API를 통해 인증 → 사용자 정보 반환.
        - **통합 도구 및 플랫폼**:
            - **Postman**: API 테스트 및 디버깅 도구.
            - **Swagger**: API 설계와 문서화 도구.
            - **MuleSoft, Zapier**: 다양한 API와 서비스 간의 통합을 지원하는 플랫폼.

# 소프트웨어 보안

### 보안 위협과 취약점

- 위협
    - 정의:
        - 소프트웨어의 안정성과 기밀성을 위협하는 **내부 또는 외부의 악의적인 활동**.
    - 예시:
        - **SQL Injection**: 입력 필드에 악의적인 SQL 코드를 삽입하여 데이터베이스에 무단 접근.
        - **Cross-Site Scripting (XSS)**: 사용자 입력값에 스크립트를 삽입하여 악성 코드 실행.
        - **데이터 유출**: 민감한 데이터가 암호화되지 않거나 안전하게 저장되지 않을 때 발생.
        - **서비스 거부 공격 (DDoS)**: 네트워크를 과부하 상태로 만들어 시스템 작동을 방해.
- 취약점
    - 정의:
        - 소프트웨어 코드나 설정 상의 결함으로 인해 발생하는 보안 약점.
    - 예시:
        - 인증 및 세션 관리의 부적절한 구현.
        - 데이터 암호화의 부재 또는 약한 암호화 방식 사용.
        - 사용자 입력값 검증 부족.

### 안전한 소프트웨어 개발 원칙

- **개요**:
    - 보안 위협을 예방하고 소프트웨어의 안정성을 높이기 위해 모든 개발 단계에서 보안 요소를 반영한다.
- **주요 원칙**:
    1. **입력값 검증:** 모든 입력값을 신뢰하지 말고 철저히 검증한다.
    2. **최소 권한 원칙**: 사용자나 프로세스가 **필요한 최소한의 권한**만 가지도록 설정한다.
    3. **데이터 암호화:** 민감한 데이터는 반드시 암호화하여 저장 및 전송한다.
        - 최신 암호화 알고리즘(AES, RSA) 사용을 권장한다.
    4. **안전한 인증 및 세션 관리:** 비밀번호는 안전한 해시 알고리즘으로 저장한다.
    5. **오류와 예외 처리**: 오류 메시지에 민감한 정보가 노출되지 않도록 주의한다.

### 보안 테스트와 취약점 분석

- 정의:
    - 소프트웨어에 존재하는 보안 취약점을 찾아내고, 이를 개선하기 위한 테스트.
- 주요 기법
    1. **정적 분석(Static Analysis)**:
        - 코드를 실행하지 않고 정적 분석 도구를 사용하여 잠재적 취약점을 식별한다.
        - **도구**: SonarQube, Checkmarx.
    2. **동적 분석(Dynamic Analysis)**:
        - 실행 중인 애플리케이션의 취약점을 탐지한다.
        - **도구**: OWASP ZAP, Burp Suite.
    3. **침투 테스트(Penetration Testing)**:
        - 실제 공격을 모방하여 보안 취약점을 탐지한다.
        - **도구**: Metasploit, Nessus.
    4. **취약점 스캐닝**:
        - 네트워크와 시스템의 취약점을 자동으로 탐지한다.
        - **도구**: Nessus, QualysGuard.

### 보안 관리와 데이터 보호

- **보안 관리**:
    - **접근 제어**:
        - 사용자와 시스템의 역할에 따라 권한을 제한한다.
    - **로그 관리 및 모니터링**:
        - 보안 이벤트를 기록하고, 이상 징후를 모니터링한다.
- **데이터 보호**:
    1. **암호화**:
        - 민감한 데이터를 저장하거나 전송할 때 강력한 암호화 알고리즘을 사용한다. (AES, RSA 등).
    2. **백업**:
        - 정기적으로 데이터를 백업하여 사고 시 복구 가능성을 보장한다.
        - 백업 데이터도 암호화하여 저장한다.
    3. **GDPR 및 개인정보 보호법 준수**:
        - 데이터 보호 관련 법규를 준수하여 개인정보를 안전하게 관리한다.
    4. **보안 패치**:
        - 소프트웨어의 최신 보안 업데이트를 유지하여 알려진 취약점을 방지한다.